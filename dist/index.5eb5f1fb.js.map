{"mappings":"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","sources":["src/js/Utilities/loop.js","src/js/Utilities/updateObject.js","src/js/Managers/game.js","src/js/Utilities/debugDetail.js","src/js/Cards/powers.js","src/js/Cards/cards.js","src/js/Managers/deck.js","src/js/Player/player_states.js","src/js/Managers/player.js","src/js/Player/player.js","src/js/Managers/view.js","src/js/View/drawPlayerDecks.js","src/js/View/drawDiscardDeck.js","src/js/View/updateView.js","src/js/View/outputToBoard.js","src/js/Gameplay/End/hasWinConditionBeenReached.js","src/js/Gameplay/Powers/applyPowerEffect.js","src/js/Gameplay/Play/checkLegalPlayableMove.js","src/js/Gameplay/Play/handlePlayCard.js","src/js/Gameplay/Play/playCard.js","src/js/Gameplay/Play/onAIPlayerCardSelect.js","src/js/Gameplay/Pickup/pickupCardFromDeck.js","src/js/Gameplay/Pickup/handleCardPickup.js","src/js/Gameplay/Begin/chooseAIPlayerActionChoice.js","src/js/Gameplay/Begin/handleTurnBegin.js","src/js/Gameplay/Powers/resolvePowerEffectState.js","src/js/Gameplay/End/onEndTurn.js","src/js/Gameplay/End/endTurn.js","src/js/Gameplay/Play/onHumanPlayerCardSelect.js","src/js/index.js"],"sourcesContent":["/**\n * \n * @param {*} array: array to loop over\n * @param {*} cb: callback for each loop\n * @param {int} dir: direction of loop, 1 for inc, -1 for decre\n * @param {*} scope \n * @returns \n */\nexport default function loop(array, cb, dir = 1, scope = undefined) {\n    if (\n        !Array.isArray(array) &&\n        // eslint-disable-next-line no-prototype-builtins\n        !NodeList.prototype.isPrototypeOf(array) &&\n        // eslint-disable-next-line no-prototype-builtins\n        !HTMLCollection.prototype.isPrototypeOf(array)\n    )\n        return;\n\n    let i = dir == 1 ? 0 : array.length - 1,\n        l = dir == 1 ? array.length : 0;\n\n    for (i; (dir == 1 ? i < l : i > l); (dir == 1 ? i++ : i--)) {\n        cb.call(scope, array[i], i);\n    }\n}\n","export const updateObject = (oldObject, newObj) => {\n    for (const key in newObj) {\n        if (Object.hasOwnProperty.call(newObj, key)) {\n            oldObject[key] = newObj[key];\n        }\n    }\n}","import { updateObject } from \"./../Utilities/updateObject\";\n\n// * Manage the running of the game, linking components\nconst GameManager = () => {\n\n    const state = {\n        mode: \"DEBUG\",\n\n        active_player: null,\n        AI_interval_speed: null,\n        AI_interval: null,\n\n        // current_game_state: \"INIT\"\n\n    }\n\n    // * Initialise the game world with a new config\n    const init = (config = {}) => {\n        updateObject(state, config);\n    }\n\n    // * Get current game state\n    const getCurrentGameState = () => {\n        return state.current_game_state;\n    }\n\n    // * Set current game state\n    const setCurrentGameState = (game_state) => {\n        updateObject(state, {\n            current_game_state: game_state\n        })\n    }\n\n    return {\n        init,\n        getCurrentGameState,\n        setCurrentGameState,\n    }\n\n}\n\nexport const Game = GameManager();","\n// * Output detail - TODO: Make better view\nexport default debugDetail = detail => console.log(detail);","export const PICKUP_2 = \"PICKUP_2\";\nexport const PICKUP_7 = \"PICKUP_7\";\nexport const MISS_TURN = \"MISS_TURN\";\nexport const ANOTHER_TURN = \"ANOTHER_TURN\";\nexport const CHANGE_DIRECTION = \"CHANGE_DIRECTION\";\nexport const CHANGE_SUIT = \"CHANGE_SUIT\";","import * as POWERS from \"./powers\";\n\nexport const cards = [\n    { value: \"A\", suit: \"hearts\", name: \"Ace of Hearts\", t: 2, l: 0, power: POWERS.CHANGE_SUIT }, //4\n    { value: 13, suit: \"hearts\", name: \"King of Hearts\", t: 2, l: 12, power: POWERS.ANOTHER_TURN },\n    { value: 12, suit: \"hearts\", name: \"Queen of Hearts\", t: 2, l: 11 },\n    { value: 11, suit: \"hearts\", name: \"Jack of Hearts\", t: 2, l: 10 },\n    { value: 10, suit: \"hearts\", name: \"10 of Hearts\", t: 2, l: 9, power: POWERS.CHANGE_DIRECTION }, //2\n    { value: 9, suit: \"hearts\", name: \"9 of Hearts\", t: 2, l: 8 },\n    { value: 8, suit: \"hearts\", name: \"8 of Hearts\", t: 2, l: 7, power: POWERS.MISS_TURN },\n    { value: 7, suit: \"hearts\", name: \"7 of Hearts\", t: 2, l: 6 },\n    { value: 6, suit: \"hearts\", name: \"6 of Hearts\", t: 2, l: 5 },\n    { value: 5, suit: \"hearts\", name: \"5 of Hearts\", t: 2, l: 4 },\n    { value: 4, suit: \"hearts\", name: \"4 of Hearts\", t: 2, l: 3 },\n    { value: 3, suit: \"hearts\", name: \"3 of Hearts\", t: 2, l: 2 },\n    { value: 2, suit: \"hearts\", name: \"2 of Hearts\", t: 2, l: 1, power: POWERS.PICKUP_2 },\n    { value: \"A\", suit: \"clubs\", name: \"Ace of Clubs\", t: 0, l: 0, power: POWERS.CHANGE_SUIT }, //4\n    { value: 13, suit: \"clubs\", name: \"King of Clubs\", t: 0, l: 12, power: POWERS.ANOTHER_TURN },\n    { value: 12, suit: \"clubs\", name: \"Queen of Clubs\", t: 0, l: 11 },\n    { value: 11, suit: \"clubs\", name: \"Jack of Clubs\", t: 0, l: 10, power: POWERS.PICKUP_7 },\n    { value: 10, suit: \"clubs\", name: \"10 of Clubs\", t: 0, l: 9, power: POWERS.CHANGE_DIRECTION }, //2\n    { value: 9, suit: \"clubs\", name: \"9 of Clubs\", t: 0, l: 8 },\n    { value: 8, suit: \"clubs\", name: \"8 of Clubs\", t: 0, l: 7, power: POWERS.MISS_TURN },\n    { value: 7, suit: \"clubs\", name: \"7 of Clubs\", t: 0, l: 6 },\n    { value: 6, suit: \"clubs\", name: \"6 of Clubs\", t: 0, l: 5 },\n    { value: 5, suit: \"clubs\", name: \"5 of Clubs\", t: 0, l: 4 },\n    { value: 4, suit: \"clubs\", name: \"4 of Clubs\", t: 0, l: 3 },\n    { value: 3, suit: \"clubs\", name: \"3 of Clubs\", t: 0, l: 2 },\n    { value: 2, suit: \"clubs\", name: \"2 of Clubs\", t: 0, l: 1, power: POWERS.PICKUP_2 },\n    { value: \"A\", suit: \"diamonds\", name: \"Ace of Diamonds\", t: 1, l: 0, power: POWERS.CHANGE_SUIT }, //4\n    { value: 13, suit: \"diamonds\", name: \"King of Diamonds\", t: 1, l: 12, power: POWERS.ANOTHER_TURN },\n    { value: 12, suit: \"diamonds\", name: \"Queen of Diamonds\", t: 1, l: 11 },\n    { value: 11, suit: \"diamonds\", name: \"Jack of Diamonds\", t: 1, l: 10 },\n    { value: 10, suit: \"diamonds\", name: \"10 of Diamonds\", t: 1, l: 9, power: POWERS.CHANGE_DIRECTION }, //2\n    { value: 9, suit: \"diamonds\", name: \"9 of Diamonds\", t: 1, l: 8 },\n    { value: 8, suit: \"diamonds\", name: \"8 of Diamonds\", t: 1, l: 7, power: POWERS.MISS_TURN },\n    { value: 7, suit: \"diamonds\", name: \"7 of Diamonds\", t: 1, l: 6 },\n    { value: 6, suit: \"diamonds\", name: \"6 of Diamonds\", t: 1, l: 5 },\n    { value: 5, suit: \"diamonds\", name: \"5 of Diamonds\", t: 1, l: 4 },\n    { value: 4, suit: \"diamonds\", name: \"4 of Diamonds\", t: 1, l: 3 },\n    { value: 3, suit: \"diamonds\", name: \"3 of Diamonds\", t: 1, l: 2 },\n    { value: 2, suit: \"diamonds\", name: \"2 of Diamonds\", t: 1, l: 1, power: POWERS.PICKUP_2 },\n    { value: \"A\", suit: \"spades\", name: \"Ace of Spades\", t: 3, l: 0, power: POWERS.CHANGE_SUIT }, //4\n    { value: 13, suit: \"spades\", name: \"King of Spades\", t: 3, l: 12, power: POWERS.ANOTHER_TURN },\n    { value: 12, suit: \"spades\", name: \"Queen of Spades\", t: 3, l: 11 },\n    { value: 11, suit: \"spades\", name: \"Jack of Spades\", t: 3, l: 10, power: POWERS.PICKUP_7 },\n    { value: 10, suit: \"spades\", name: \"10 of Spades\", t: 3, l: 9, power: POWERS.CHANGE_DIRECTION }, //2\n    { value: 9, suit: \"spades\", name: \"9 of Spades\", t: 3, l: 8 },\n    { value: 8, suit: \"spades\", name: \"8 of Spades\", t: 3, l: 7, power: POWERS.MISS_TURN },\n    { value: 7, suit: \"spades\", name: \"7 of Spades\", t: 3, l: 6 },\n    { value: 6, suit: \"spades\", name: \"6 of Spades\", t: 3, l: 5 },\n    { value: 5, suit: \"spades\", name: \"5 of Spades\", t: 3, l: 4 },\n    { value: 4, suit: \"spades\", name: \"4 of Spades\", t: 3, l: 3 },\n    { value: 3, suit: \"spades\", name: \"3 of Spades\", t: 3, l: 2 },\n    { value: 2, suit: \"spades\", name: \"2 of Spades\", t: 3, l: 1, power: POWERS.PICKUP_2 },\n];","import debugDetail from \"../Utilities/debugDetail\";\nimport { cards } from \"./../Cards/cards\";\nimport loop from \"./../Utilities/loop\";\n\nimport { updateObject } from \"./../Utilities/updateObject\";\n\nconst DeckManager = () => {\n\n    const PICKUP_DECK = cards;\n\n    const DISCARD_DECK = [];\n\n    const state = {\n        starting_hand_size: 7,\n    }\n\n    const init = (config) => {\n        updateObject(state, config);\n    }\n\n    const prepareDeck = () => {\n        // * Shuffle Pickup deck\n        shufflePickUpDeck();\n\n        // * Move top card from Pickup to Discard Deck\n        insertCardAtIndexToDiscardDeck(0, removeCardByIndexFromPickupDeck(0));\n    }\n\n    // * Shuffle the deck\n    const shufflePickUpDeck = () => {\n        shuffle(\n            PICKUP_DECK,\n            removeCardByIndexFromPickupDeck,\n            insertCardAtIndexToPickupDeck\n        );\n    }\n\n    const shuffleDiscardDeck = () => {\n        shuffle(\n            DISCARD_DECK,\n            removeCardByIndexFromDiscardDeck,\n            insertCardAtIndexToDiscardDeck\n        );\n    }\n\n    const shuffle = (deck, get, insert) => {\n        let r, card;\n\n        // Create a copy of the cardArray to shuffle (Works by swapping the last card with a randomly selected card)\n        loop(deck, (c, idx) => {\n            // Get a random Integer\n            r = Math.floor(Math.random() * idx);\n            // Get the next last card in the Store.deck\n            card = get(idx - 1);\n            // Whatever card was initially chosen, place a randomly selected one there now\n            insert((idx - 1), get(r));\n            // Place the card that was initially chosen in the position of the randomly selected card\n            insert([r], card);\n        }, -1)\n    }\n\n    // * Deal the cards to the players\n    const dealCards = (players) => {\n        loop(players, (player, p) => {\n            let cards = removeFirstNCardsFromPickupDeck(state.starting_hand_size);\n\n            player.addCards(cards);\n        });\n    }\n\n    const getPickupDeck = () => {\n        return PICKUP_DECK;\n    }\n\n    const getPickupDeckTopCard = () => {\n        return PICKUP_DECK[0];\n    }\n\n    const getPickupDeckSize = () => {\n        return PICKUP_DECK.length;\n    }\n\n    const getDiscardDeck = () => {\n        return DISCARD_DECK;\n    }\n\n    const getDiscardDeckTopCard = () => {\n        return DISCARD_DECK[0];\n    }\n\n    const getDiscardDeckSize = () => {\n        return DISCARD_DECK.length;\n    }\n\n    const removeCardByIndexFromPickupDeck = (idx) => {\n        return PICKUP_DECK.splice(idx, 1)[0];\n    }\n\n    const removeCardByIndexFromDiscardDeck = (idx) => {\n        return DISCARD_DECK.splice(idx, 1)[0];\n    }\n\n    const removeFirstNCardsFromPickupDeck = (num_cards) => {\n        return PICKUP_DECK.splice(0, num_cards);\n    }\n\n    const removeFirstNCardsFromDiscardDeck = (num_cards) => {\n        return DISCARD_DECK.splice(0, num_cards);\n    }\n\n    const removeCardAtIndexFromPickupDeck = (idx) => {\n        return PICKUP_DECK.splice(idx, 1)[0];\n    }\n\n    const removeCardAtIndexFromDiscardDeck = (idx) => {\n        return DISCARD_DECK.splice(idx, 1)[0];\n    }\n\n    const insertCardAtIndexToPickupDeck = (idx, card) => {\n        PICKUP_DECK.splice(idx, 0, card);\n    }\n\n    const insertCardAtIndexToDiscardDeck = (idx, card) => {\n        DISCARD_DECK.splice(idx, 0, card);\n    }\n\n    const insertToTopOfPickupDeck = (card) => {\n        PICKUP_DECK.unshift(card);\n    }\n\n    const insertToTopOfDiscardDeck = (card) => {\n        DISCARD_DECK.unshift(card);\n    }\n\n    const swapDecks = () => {\n        debugDetail(`Refilling Pickup Deck from Discard Deck`);\n\n        // TODO - What if no cards are left?\n\n        // * Move all discarded cards to pickup deck, leaving last discarded card in discard pile\n        const top_discard_card = removeCardAtIndexFromDiscardDeck(0);\n\n        // * loop through remaining discard deck and add to pickup deck\n        for (let idx = 0; idx < getDiscardDeckSize(); idx++) {\n            insertToTopOfPickupDeck(removeCardByIndexFromDiscardDeck(idx));\n        }\n\n        // * add initial discarded card back to discard pile\n        insertToTopOfDiscardDeck(top_discard_card);\n    }\n\n    return {\n        init,\n        prepareDeck,\n\n        getPickupDeck,\n        getPickupDeckSize,\n        getPickupDeckTopCard,\n        removeCardByIndexFromPickupDeck,\n        removeFirstNCardsFromPickupDeck,\n        removeCardAtIndexFromPickupDeck,\n        insertCardAtIndexToPickupDeck,\n        insertToTopOfPickupDeck,\n\n        getDiscardDeck,\n        getDiscardDeckSize,\n        getDiscardDeckTopCard,\n        removeCardByIndexFromDiscardDeck,\n        removeFirstNCardsFromDiscardDeck,\n        removeCardAtIndexFromDiscardDeck,\n        insertCardAtIndexToDiscardDeck,\n        insertToTopOfDiscardDeck,\n\n        shufflePickUpDeck,\n        shuffleDiscardDeck,\n\n        swapDecks,\n\n        dealCards,\n    }\n\n}\n\nexport const Deck = DeckManager();\n","export const IDLE = \"IDLE\";\nexport const TO_PLAY = \"TO_PLAY\";\nexport const HAS_PLAYED = \"HAS_PLAYED\";\n\nexport const ACTION_DID_PICKUP = \"DID_PICKUP\";\nexport const ACTION_DID_PUTDOWN = \"DID_PUTDOWN\";\nexport const ACTION_NO_ACTION = \"NO_ACTION\";\n\nexport const EFFECT_MUST_PICK_2 = \"MUST_PICK_2\";\nexport const EFFECT_MUST_PICK_7 = \"MUST_PICK_7\";\nexport const EFFECT_MUST_MISS_TURN = \"MUST_MISS_TURN\";\nexport const EFFECT_ANOTHER_TURN = \"EFFECT_ANOTHER_TURN\";\nexport const EFFECT_NO_EFFECT = \"EFFECT_NO_EFFECT\";","import { updateObject } from \"./../Utilities/updateObject\";\nimport { Player } from \"../Player/player\";\nimport debugDetail from \"../Utilities/debugDetail\";\nimport * as PLAYER_STATES from \"../Player/player_states\";\n\nimport loop from \"../Utilities/loop\";\n\nconst PlayerManager = () => {\n\n    const state = {\n        num_players: 4,\n        player_list: [],\n        current_player_idx: 0,\n        previous_player_idx: null,\n        next_player_idx: null,\n        play_direction: 1,\n    }\n\n    const init = (config) => {\n        updateObject(state, config);\n\n        state.previous_player_idx = determinePreviousPlayerIdx();\n        state.next_player_idx = determineNextPlayerIdx();\n    }\n\n    const determineNextPlayerIdx = () => {\n        let next_idx = state.current_player_idx + state.play_direction;\n\n        return next_idx < 0 ? state.num_players - 1 : next_idx >= state.num_players ? 0 : next_idx;\n    }\n\n    const determinePreviousPlayerIdx = () => {\n        let prev_idx = state.current_player_idx - state.play_direction;\n\n        return prev_idx < 0 ? state.num_players - 1 : prev_idx >= state.num_players ? 0 : prev_idx;\n    }\n\n    const createPlayers = (player_configs) => {\n\n        loop(player_configs, (config) => {\n            let player = Player();\n\n            player.init({\n                is_human: config.is_human,\n                name: config.name,\n                el: config.el\n            });\n\n            state.player_list.push(player);\n        });\n    }\n\n    const setNextActivePlayer = () => {\n        // * set the next player to current\n        state.current_player_idx = state.next_player_idx;\n\n\n        // * current idx now becomes previous idx\n        state.previous_player_idx = determinePreviousPlayerIdx();\n\n        // * Get and update new previous\n        let previous_player = state.player_list[state.previous_player_idx];\n        // * Reset to idle\n        previous_player.resetStatus();\n\n\n        // * next player now becomes next + (1 || -1)\n        state.next_player_idx = determineNextPlayerIdx();\n\n\n        // * Get and update new current player\n        let current_player = state.player_list[state.current_player_idx];\n        // * Ensure no effects are in place\n        if (current_player.getEffectState() === PLAYER_STATES.EFFECT_NO_EFFECT) {\n            // * unaffected, normal play\n            current_player.updatePlayState(PLAYER_STATES.TO_PLAY);\n        } else {\n            // * has been affected\n        }\n\n        debugDetail(`Current active player is now: ${current_player.getPlayerName()}`);\n    }\n\n    const getCurrentActivePlayer = () => {\n        return state.player_list[state.current_player_idx];\n    }\n\n    const getCurrentActivePlayerIdx = () => {\n        return state.current_player_idx;\n    }\n\n    const getCurrentNextPlayer = () => {\n        return state.player_list[state.next_player_idx];\n    }\n\n    const getCurrentNextPlayerIdx = () => {\n        return state.next_player_idx;\n    }\n\n    const getCurrentPreviousPlayer = () => {\n        return state.player_list[state.previous_player_idx];\n    }\n\n    const getCurrentPreviousPlayerIdx = () => {\n        return state.previous_player_idx;\n    }\n\n    const getPlayerList = () => {\n        return state.player_list;\n    }\n\n    const changePlayDirection = () => {\n        state.play_direction = state.play_direction * -1;\n\n        // * set next to previous player\n        state.next_player_idx = state.previous_player_idx;\n    }\n\n    return {\n        init,\n        createPlayers,\n        setNextActivePlayer,\n        getCurrentActivePlayer,\n        getCurrentActivePlayerIdx,\n        getCurrentNextPlayer,\n        getCurrentNextPlayerIdx,\n        getCurrentPreviousPlayer,\n        getCurrentPreviousPlayerIdx,\n        getPlayerList,\n        changePlayDirection,\n    }\n\n}\n\nexport const Players = PlayerManager();","import debugDetail from \"../Utilities/debugDetail\";\nimport { updateObject } from \"./../Utilities/updateObject\";\n\nimport * as PLAYER_STATES from \"./player_states\";\n\nexport const Player = () => {\n    const state = {\n        name: null,\n        deck: [],\n        el: null,\n        is_human: false,\n\n        status: {\n            play_state: PLAYER_STATES.IDLE,\n            action: PLAYER_STATES.ACTION_NO_ACTION,\n            effect: PLAYER_STATES.EFFECT_NO_EFFECT,\n        }\n    }\n\n    // * Initialise the player with a config object\n    const init = (config) => {\n        updateObject(state, config);\n    }\n\n    // * Add a card to the player deck\n    const addCard = (card) => {\n        state.deck.push(card);\n    }\n\n    // * Add cards to the player deck\n    const addCards = (cards) => {\n        state.deck = state.deck.concat(cards);\n    }\n\n    // * Remove a card at index\n    const removeCardAtIndex = (idx) => {\n        state.deck.splice(idx, 1)[0];\n    }\n\n    // * Remove a number of cards starting at index\n    const removeCards = (idx, num_cards) => {\n        state.deck.splice(idx, num_cards);\n    }\n\n    // * Remove a selected card by value/suit\n    const removeCard = ({ value, suit }) => {\n        let cardIdx = state.deck.findIndex((card) => {\n            return card.value == value && card.suit == suit;\n        });\n\n        if (cardIdx < 0) {\n            console.error(\"Selected player card not found\");\n        }\n\n        return state.deck.splice(cardIdx, 1)[0];\n    }\n\n    // * Get the players name\n    const getPlayerName = () => {\n        return state.name;\n    }\n\n    // * Get is the player human\n    const getIsHuman = () => {\n        return state.is_human;\n    }\n\n    // * Get current cards\n    const getCurrentCards = () => {\n        return state.deck;\n    }\n\n    // * Get current hand size\n    const getHandSize = () => {\n        return state.deck.length;\n    }\n\n    // * Reset the player status\n    const resetStatus = () => {\n        state.status = {\n            play_state: PLAYER_STATES.IDLE,\n            action: PLAYER_STATES.ACTION_NO_ACTION,\n            effect: PLAYER_STATES.EFFECT_NO_EFFECT,\n        };\n    }\n\n    // * Get the full player status\n    const getStatus = () => {\n        return state.status;\n    }\n\n    // * update the play state\n    const updatePlayState = (play_state) => {\n        // * Check acceptable state provided\n        if (![\n            PLAYER_STATES.IDLE,\n            PLAYER_STATES.TO_PLAY,\n            PLAYER_STATES.HAS_PLAYED\n        ].includes(play_state)) {\n            debugDetail(`${state.name} [state.play_state] provided unacceptable state: ${play_state}`);\n        }\n\n        state.status.play_state = play_state;\n        debugDetail(`${state.name} [state.play_state] is now ${play_state}`);\n    }\n\n    // * get the players current play state\n    const getPlayState = () => {\n        return state.status.play_state;\n    }\n\n    // * update the action state\n    const updateActionState = (action_state) => {\n        // * Check acceptable state provided\n        if (![\n            PLAYER_STATES.ACTION_DID_PICKUP,\n            PLAYER_STATES.ACTION_DID_PUTDOWN,\n            PLAYER_STATES.ACTION_NO_ACTION,\n        ].includes(action_state)) {\n            debugDetail(`${state.name} [state.action_state] provided unacceptable state: ${action_state}`);\n        }\n        state.status.action = action_state;\n        debugDetail(`${state.name} [state.action] is now ${action_state}`);\n    }\n\n    // * get the players action state\n    const getActionState = () => {\n        return state.status.action;\n    }\n\n    // * update the effect state\n    const updateEffectState = (effect_state) => {\n        // * Check acceptable state provided\n        if (![\n            PLAYER_STATES.EFFECT_MUST_PICK_2,\n            PLAYER_STATES.EFFECT_MUST_PICK_7,\n            PLAYER_STATES.EFFECT_MUST_MISS_TURN,\n            PLAYER_STATES.EFFECT_ANOTHER_TURN,\n            PLAYER_STATES.EFFECT_NO_EFFECT,\n        ].includes(effect_state)) {\n            debugDetail(`${state.name} [state.effect_state] provided unacceptable state: ${effect_state}`);\n        }\n        state.status.effect = effect_state;\n        debugDetail(`${state.name} [state.effect] is now ${effect_state}`);\n    }\n\n    // * get the players current effect state\n    const getEffectState = () => {\n        return state.status.effect;\n    }\n\n    const getPlayerEl = () => {\n        return state.el;\n    }\n\n    return {\n        init,\n\n        addCard,\n        addCards,\n\n        removeCard,\n        removeCardAtIndex,\n        removeCards,\n\n        getPlayerName,\n        getCurrentCards,\n        getIsHuman,\n        getHandSize,\n        getPlayerEl,\n\n        resetStatus,\n        getStatus,\n\n        updatePlayState,\n        getPlayState,\n        updateActionState,\n        getActionState,\n        updateEffectState,\n        getEffectState,\n    }\n}","import { updateObject } from \"./../Utilities/updateObject\";\n\nconst ViewManager = () => {\n\n    const state = {\n        pickup_deck_el: null,\n        discard_deck_el: null,\n        updates_board_el: null,\n\n        card_w: 59,\n        card_h: 90,\n    }\n\n    const init = (config = {}) => {\n        updateObject(state, config);\n    }\n\n    const createCardHTML = (card, is_facing) => {\n        return (\n            `<img class=\"${is_facing ? \"face_up\" : \"face_down\"}\" style=\"background-position: -${card.l * state.card_w}px -${card.t * state.card_h}px;\"/>`\n        )\n    }\n\n    const createListedCardHTML = (card, is_facing) => {\n        return (\n            `<li class=\"card\" data-v=\"${card.value}\" data-s=\"${card.suit}\">\n                ${createCardHTML(card, is_facing)}\n            </li>`\n        );\n    }\n\n    const getPickupDeck = () => {\n        return state.pickup_deck_el;\n    }\n\n    const getDiscardDeck = () => {\n        return state.discard_deck_el;\n    }\n\n    const getGameUpdateBoard = () => {\n        return state.updates_board_el;\n    }\n\n    return {\n        init,\n\n        createListedCardHTML,\n        createCardHTML,\n\n        getPickupDeck,\n        getDiscardDeck,\n\n        getGameUpdateBoard,\n    }\n}\n\nexport const View = ViewManager();","import loop from \"./../Utilities/loop\";\nimport { Players, View } from \"./../Managers/managers\";\n\n// * Define player decks\nexport default drawPlayerDecks = () => {\n\n    loop(Players.getPlayerList(), (player) => {\n        const deck = player.getCurrentCards();\n\n        // * get deck element\n        const deck_el = player.getPlayerEl().querySelector('.card_list');\n\n        // * remove HTML\n        deck_el.innerHTML = \"\";\n\n        loop(deck, (card) => {\n            deck_el.insertAdjacentHTML(\n                \"beforeend\",\n                View.createListedCardHTML(card, player.getIsHuman())\n            );\n        });\n    });\n}","import { Deck, View } from \"./../Managers/managers\";\n\nexport default drawDiscardDeck = () => {\n\n    let card = Deck.getDiscardDeck()[0];\n    View.getDiscardDeck().innerHTML = View.createCardHTML(card, true);\n}","import drawPlayerDecks from \"./drawPlayerDecks\";\nimport drawDiscardDeck from \"./drawDiscardDeck\";\n\nexport default updateView = () => {\n\n    // * Draw player decks\n    drawPlayerDecks();\n    // * Draw discard decks\n    drawDiscardDeck();\n}","import { View } from \"./../Managers/managers\";\n\n// * Output message to the game board\nexport default outputToBoard = (message) => {\n\n    const update_board = View.getGameUpdateBoard();\n\n    update_board.insertAdjacentHTML(\"beforeend\", `<p>${message}</p>`);\n    update_board.scrollTop = update_board.scrollHeight;\n}","import { Players } from \"../../Managers/managers\";\nimport debugDetail from \"../../Utilities/debugDetail\";\n\n// * Test if a win condition has been reached\nexport default hasWinConditionBeenReached = () => {\n\n    debugDetail(`[hasWinConditionBeenReached] Checking win condition`);\n\n    // * Current player has won if they have no cards left\n    let num_cards_remaining = Players.getCurrentActivePlayer().getHandSize();\n\n    debugDetail(`[hasWinConditionBeenReached] Player has ${num_cards_remaining} cards remaining`);\n\n    // * To win there has to be no cards remaining\n    // TODO - last placed card should not be a power card and player needs to pick up\n    return num_cards_remaining === 0;\n}","import * as POWERS from \"./../../Cards/powers\";\nimport * as PLAYER_STATES from \"./../../Player/player_states\";\nimport outputToBoard from \"../../View/outputToBoard\";\nimport { Players } from \"./../../Managers/managers\";\n\n// * Apply power effects from power card\nexport default applyPowerEffect = (power) => {\n\n    const current_active_player = Players.getCurrentActivePlayer();\n    const current_next_player = Players.getCurrentNextPlayer();\n\n    switch (power) {\n        case POWERS.CHANGE_DIRECTION:\n\n            // * Change play direction\n            outputToBoard(`Direction of play is reversed!`);\n            Players.changePlayDirection();\n\n            break;\n\n        case POWERS.CHANGE_SUIT:\n\n            // * Change playable suit\n            outputToBoard(`New suit chosen! [TODO]`);\n            // TODO\n            break;\n\n        case POWERS.ANOTHER_TURN:\n\n            // * Player has another go\n            outputToBoard(`${current_active_player.getPlayerName()} to take another turn!`);\n            current_active_player.updateEffectState(PLAYER_STATES.EFFECT_ANOTHER_TURN);\n            break;\n\n        case POWERS.MISS_TURN:\n\n            // * Next player misses turn\n            outputToBoard(`${current_next_player.getPlayerName()} to miss a turn!`);\n            current_next_player.updateEffectState(PLAYER_STATES.EFFECT_MUST_MISS_TURN);\n            break;\n\n        case POWERS.PICKUP_2:\n\n            // * Next player must pickup 2\n            outputToBoard(`${current_next_player.getPlayerName()} must pick up 2 cards!`);\n            current_next_player.updateEffectState(PLAYER_STATES.EFFECT_MUST_PICK_2);\n            break;\n\n        case POWERS.PICKUP_7:\n\n            // * Next player must pickup 7\n            outputToBoard(`${current_next_player.getPlayerName()} must pick up 7 cards!`);\n            current_next_player.updateEffectState(PLAYER_STATES.EFFECT_MUST_PICK_7);\n            break;\n\n        default:\n\n            debugDetail(`[applyPowerEffect] Unknown power applied! ${power}`);\n    }\n}","import { Deck } from \"./../../Managers/managers\";\n\nexport default checkLegalPlayableMove = ({ value, suit }) => {\n\n    // * get current card attempting to play upon\n    const current_top_card = Deck.getDiscardDeckTopCard();\n\n    // * playable card must be of the same suit or of the same value\n    return (value == current_top_card.value) || (suit == current_top_card.suit);\n}","import { Deck, Players } from \"./../../Managers/managers\";\nimport debugDetail from \"../../Utilities/debugDetail\";\n\nimport * as PLAYER_STATES from \"./../../Player/player_states\";\n\n// * Play the given card\nexport default handlePlayCard = ({ value, suit }) => {\n\n    // * get card from player hand\n    let current_player = Players.getCurrentActivePlayer();\n\n    const card = current_player.removeCard({\n        value,\n        suit\n    });\n\n    debugDetail(`[playCard] Playing card: ${card.name}`);\n\n    // * place card to discard deck\n    Deck.insertToTopOfDiscardDeck(card);\n\n    current_player.updateActionState(PLAYER_STATES.ACTION_DID_PUTDOWN);\n\n    outputToBoard(`${current_player.getPlayerName()} has played the ${card.name}`);\n\n    updateView();\n}","import debugDetail from \"../../Utilities/debugDetail\";\nimport outputToBoard from \"../../View/outputToBoard\";\nimport checkLegalPlayableMove from \"./checkLegalPlayableMove\";\nimport handlePlayCard from \"./handlePlayCard\";\n\n// * Attempt to play a card\nexport default playCard = ({ value, suit }) => {\n\n    debugDetail(`[handlePlayCard] Attempting to play`);\n\n    // * Check whether card can be played\n    if (!checkLegalPlayableMove({ value, suit })) {\n        debugDetail(`[handlePlayCard] Card not playable`);\n        outputToBoard(`That card isn't playable!`);\n\n        // * card not playable\n        return false;\n    }\n\n    // * card is playable, so play it\n    handlePlayCard({ value, suit });\n\n    // * card is playable\n    return true;\n}\n","import debugDetail from \"../../Utilities/debugDetail\";\nimport playCard from \"./playCard\";\nimport endTurn from \"../End/endTurn\";\n\n// * Define AI Player Interactions\nexport default onAIPlayerCardSelect = (playable_cards) => {\n\n    // * AI Player select card from hand\n    debugDetail(`[onAIPlayerCardSelect] Playing a card from hand`);\n\n    // * Check if any of the cards are a power card\n    let available_power_cards = playable_cards.filter(function (card) {\n\n        return typeof card.power !== \"undefined\";\n    });\n\n    // * index of card choice\n    let playing_card = null;\n\n    // * if power cards available, we want to be more likely to selecting one of them\n    if (available_power_cards.length && Math.random() > 0.4) {\n\n        // * Select from the power card list\n        playing_card = available_power_cards[Math.floor(Math.random() * available_power_cards.length)];\n\n    } else {\n\n        // * select any random card\n        playing_card = playable_cards[Math.floor(Math.random() * playable_cards.length)];\n    }\n\n    playCard({\n        value: playing_card.value,\n        suit: playing_card.suit\n    });\n\n    endTurn();\n}","import { Players, Deck } from \"./../../Managers/managers\";\n\nimport updateView from \"../../View/updateView\";\n\nimport debugDetail from \"../../Utilities/debugDetail\";\nimport outputToBoard from \"../../View/outputToBoard\";\n\nimport * as PLAYER_STATES from \"./../../Player/player_states\";\n\nexport default pickupCardFromDeck = () => {\n\n    debugDetail(`[pickupCardFromDeck] Picking up card`);\n\n    // * get current player attempting pickup\n    let current_player = Players.getCurrentActivePlayer();\n\n    // * get pickup deck\n    let top_card = Deck.removeCardByIndexFromPickupDeck(0);\n\n    // * add picked up card to player deck\n    current_player.addCard(top_card);\n\n    debugDetail(`[pickupCardFromDeck] Picked up card: ${top_card.name}`);\n\n    // * if deck is now empty, then swap decks\n    if (Deck.getPickupDeckSize() <= 0) {\n        Deck.swapDecks();\n    }\n\n    // * Update the players action state\n    current_player.updateActionState(PLAYER_STATES.ACTION_DID_PICKUP);\n\n    outputToBoard(`${current_player.getPlayerName()} has picked up`);\n\n    // * redraw the view\n    updateView();\n}","import pickupCardFromDeck from \"./pickupCardFromDeck\";\nimport endTurn from \"../End/endTurn\";\n\nexport default handleCardPickup = (e) => {\n    pickupCardFromDeck();\n    endTurn();\n}","import debugDetail from \"../../Utilities/debugDetail\";\nimport checkLegalPlayableMove from \"../Play/checkLegalPlayableMove\";\nimport onAIPlayerCardSelect from \"../Play/onAIPlayerCardSelect\";\nimport handleCardPickup from \"../Pickup/handleCardPickup\";\n\n// * Handle AI making play choice\nexport default chooseAIPlayerActionChoice = () => {\n\n    // * Get current AI player\n    const current_AI_player = Players.getCurrentActivePlayer();\n\n    // * get players current hand\n    const current_hand = current_AI_player.getCurrentCards();\n\n    // * get legal playable cards from hand\n    const playable_cards = current_hand.filter((card) => {\n\n        return checkLegalPlayableMove(card);\n    });\n\n    debugDetail(`[chooseAIPlayerActionChoice] Number of playable cards: ${playable_cards.length}`);\n\n    // * if playable cards\n    if (playable_cards.length && Math.random() >= 0.3) {\n        // * more weighting to putting down cards than picking them up\n        // * choice based on random value\n\n        // * play a card\n        debugDetail(`[chooseAIPlayerActionChoice] Player has chosen to play a card`);\n        onAIPlayerCardSelect(playable_cards);\n    } else {\n\n        // * no playable cards, so has to pickup\n        debugDetail(`Player must pickup`);\n        handleCardPickup();\n    }\n}","import debugDetail from \"../../Utilities/debugDetail\";\nimport { Players } from \"./../../Managers/managers\";\n\nimport resolvePowerEffectState from \"../Powers/resolvePowerEffectState\";\nimport chooseAIPlayerActionChoice from \"../Begin/chooseAIPlayerActionChoice\";\n\nimport * as PLAYER_STATES from \"./../../Player/player_states\";\n\nexport default handleTurnBegin = () => {\n\n    // * Resolve any effects\n\n    let current_active_player = Players.getCurrentActivePlayer();\n\n    if (current_active_player.getEffectState() !== PLAYER_STATES.EFFECT_NO_EFFECT) {\n\n        debugDetail(`Current player is affected by ${current_active_player.getEffectState()}`);\n\n        resolvePowerEffectState(\n            current_active_player,\n            current_active_player.getEffectState()\n        );\n\n    } else {\n        // * no effect in play, continue as normal\n\n        outputToBoard(`${current_active_player.getPlayerName()} to play...`);\n\n        // * if AI\n        if (!current_active_player.getIsHuman()) {\n\n            debugDetail(`[chooseAIPlayerActionChoice] Player is thinking...`);\n            // * simulate player thinking before choice (effectively slow down game)\n            window.setTimeout(chooseAIPlayerActionChoice, 2000);\n        } else {\n            // * is human\n            // ... wait for player interaction\n        }\n    }\n}","import * as PLAYER_STATES from \"./../../Player/player_states\";\nimport { Players } from \"./../../Managers/managers\";\nimport debugDetail from \"../../Utilities/debugDetail\";\nimport handleTurnBegin from \"../Begin/handleTurnBegin\";\nimport endTurn from \"../End/endTurn\";\nimport pickupCardFromDeck from \"../Pickup/pickupCardFromDeck\";\n\n// * Resolve the power effect in place\nexport default resolvePowerEffectState = (currentPlayer, effect_state) => {\n\n    const current_active_player = Players.getCurrentActivePlayer();\n\n    switch (effect_state) {\n        case PLAYER_STATES.EFFECT_ANOTHER_TURN:\n\n            // * Player has another go\n            debugDetail(`[resolvePowerEffectState] Player taking another turn [TODO]`);\n            // * reset status\n            current_active_player.resetStatus();\n            current_active_player.updatePlayState(PLAYER_STATES.TO_PLAY);\n            handleTurnBegin();\n            break;\n\n        case PLAYER_STATES.EFFECT_MUST_MISS_TURN:\n\n            // * go straight to end turn\n            debugDetail(`[resolvePowerEffectState] Missing Turn`);\n            endTurn();\n            break;\n\n        case PLAYER_STATES.EFFECT_MUST_PICK_2:\n\n            // * Next player must pickup 2 then end turn\n            debugDetail(`[resolvePowerEffectState] Picking up 2 cards`);\n            for (let c = 0; c < 2; c++) {\n                pickupCardFromDeck();\n            }\n            endTurn();\n            break;\n\n        case PLAYER_STATES.EFFECT_MUST_PICK_7:\n\n            // * Next player must pickup 7 then end turn\n            for (let c = 0; c < 7; c++) {\n                pickupCardFromDeck();\n            }\n            endTurn();\n            break;\n\n        default:\n\n            debugDetail(`[resolvePowerEffectState] Unknown effect state applied! ${effect_state}`);\n    }\n}","import { Players } from \"./../../Managers/managers\";\nimport debugDetail from \"../../Utilities/debugDetail\";\n\nimport handleTurnBegin from \"../Begin/handleTurnBegin\";\n\nexport default onEndTurn = () => {\n\n    // * update current players\n    Players.setNextActivePlayer();\n\n    debugDetail(`[chooseAIPlayerActionChoice] It is now ${Players.getCurrentActivePlayer().getPlayerName()}s turn`);\n\n    // * begin next turn\n    handleTurnBegin();\n}","import { Players } from \"./../../Managers/managers\";\nimport debugDetail from \"../../Utilities/debugDetail\";\nimport outputToBoard from \"./../../View/outputToBoard\";\nimport hasWinConditionBeenReached from \"./hasWinConditionBeenReached\";\nimport applyPowerEffect from \"./../Powers/applyPowerEffect\";\nimport resolvePowerEffectState from \"./../Powers/resolvePowerEffectState\";\nimport onEndTurn from \"./onEndTurn\";\n\nimport * as PLAYER_STATES from \"./../../Player/player_states\";\n\n// * handle ending a turn\nexport default endTurn = () => {\n\n    // * resolve anything before confirm turn is ended\n\n    const current_player = Players.getCurrentActivePlayer();\n\n    current_player.updatePlayState(PLAYER_STATES.HAS_PLAYED);\n\n    debugDetail(`[endTurn] Ending turn...`);\n\n    debugDetail(`[endTurn] actionState of current player: ${current_player.getActionState()}`);\n\n    // * If player put a card down, then apply power if required\n    if (current_player.getActionState() === PLAYER_STATES.ACTION_DID_PUTDOWN) {\n\n        // * Player putdown a card, check if power card\n        const top_card = Deck.getDiscardDeckTopCard();\n\n        if (top_card.power) {\n\n            debugDetail(`[endTurn] Card putdown is a power card: ${top_card.power}`);\n            outputToBoard(`It's a power card!`);\n\n            // * Apply power effect\n            applyPowerEffect(top_card.power);\n\n            // * check if current player affected by the power card\n            // TODO - too closely linked to the Have another go power - needs to be handled elsewhere\n            if (current_player.getEffectState() !== PLAYER_STATES.EFFECT_NO_EFFECT) {\n\n                // * resolve power effect\n                resolvePowerEffectState(\n                    current_player,\n                    current_player.getEffectState()\n                );\n\n                return;\n            }\n        }\n    }\n\n    // * check if win condition has been reached\n    if (!hasWinConditionBeenReached()) {\n\n        debugDetail(`------------`);\n        onEndTurn();\n    } else {\n\n        // * Game has been won, end\n        outputToBoard(`${Players.getCurrentActivePlayer().getPlayerName()} is the winner!`);\n        debugDetail(`[endTurn] ${Players.getCurrentActivePlayer().getPlayerName()} has won!`);\n    }\n}","import debugDetail from \"../../Utilities/debugDetail\";\nimport { Players } from \"./../../Managers/managers\";\nimport endTurn from \"../End/endTurn\";\nimport playCard from \"./playCard\";\n\n// * Define Human Player Interaction\nexport default onHumanPlayerCardSelect = (event) => {\n\n    debugDetail(`[onHumanPlayerCardSelect]`);\n\n    // * check that the current player is the human player, or the user is selecting out of turn\n    if (!Players.getCurrentActivePlayer().getIsHuman()) {\n        debugDetail(`[onHumanPlayerCardSelect] Human player not currently active`);\n        return;\n    }\n\n    // * get selection target\n    const selection = event.target.parentNode || event.srcElement.parentNode;\n\n    // * make sure a card was clicked\n    if (selection.className == \"card\") {\n        // * get card reference\n        const value = selection.getAttribute('data-v');\n        const suit = selection.getAttribute('data-s');\n\n        const valid_play = playCard({ value, suit });\n\n        if (valid_play) {\n            endTurn();\n        }\n    }\n\n    // * otherwise do nothing\n}","import updateView from \"./View/updateView\";\nimport outputToBoard from \"./View/outputToBoard\";\nimport onHumanPlayerCardSelect from \"./Gameplay/Play/onHumanPlayerCardSelect\";\nimport handleCardPickup from \"./Gameplay/Pickup/handleCardPickup\";\n\nimport {\n    Game,\n    Deck,\n    Players,\n    View,\n} from \"./Managers/managers\";\n\n// * add window references for debugging\nwindow.Game = Game;\nwindow.Deck = Deck;\nwindow.Players = Players;\nwindow.View = View;\n\nimport outputToBoard from \"./View/outputToBoard\";\nimport updateView from \"./View/updateView\";\n\nconst startGame = () => {\n    // * ------ Initialisation ------- * //\n\n    // * Initialise Game World\n    Game.init({});\n\n    // * Initialise Players\n    Players.init({\n        num_players: 4,\n    });\n\n    // * Initialise View\n    View.init({\n        pickup_deck_el: document.getElementById(\"pickup_deck\"),\n        discard_deck_el: document.getElementById(\"discard_deck\"),\n        updates_board_el: document.getElementById(\"game_updates\"),\n    });\n\n    // * initialise the deck\n    Deck.init({});\n\n\n    // * ------ Preparation ------- * //\n\n    // * Create the players\n    Players.createPlayers([\n        {\n            el: document.getElementById(\"Player_0\"),\n            is_human: true,\n            name: \"Human Player\"\n        },\n        {\n            el: document.getElementById(\"Player_1\"),\n            is_human: false,\n            name: \"AI Player 1\"\n        },\n        {\n            el: document.getElementById(\"Player_2\"),\n            is_human: false,\n            name: \"AI Player 2\"\n        },\n        {\n            el: document.getElementById(\"Player_3\"),\n            is_human: false,\n            name: \"AI Player 3\"\n        },\n    ]);\n\n    // * prepare the deck\n    Deck.prepareDeck();\n\n    // * deal cards to each player\n    Deck.dealCards(Players.getPlayerList());\n\n\n    // * ------ Start Play ------- * //\n\n    // * Do initial draw\n    updateView();\n\n    // * Assign interactions to view\n    document.querySelector(\"#pickup_deck\").addEventListener(\"mousedown\", handleCardPickup);\n\n    const human_player = Players.getPlayerList().find(function (player) {\n        return player.getIsHuman();\n    });\n\n    human_player.getPlayerEl().querySelector(\".card_list\").addEventListener(\"mousedown\", onHumanPlayerCardSelect);\n\n    // *\n    outputToBoard(`The starting card is a ${Deck.getDiscardDeckTopCard().name}`);\n}\n\ndocument.querySelector(\"#game_instructions button\").addEventListener(\"click\", () => {\n    document.querySelector(\"#game_instructions\").remove();\n    startGame();\n});"],"names":["array","cb","dir","scope","Array","isArray","NodeList","prototype","isPrototypeOf","HTMLCollection","i","length","l","call","$133b7eac866cea4f$export$7c3c3186c3d08d25","oldObject","newObj","key","Object","hasOwnProperty","$44eb225e577f5b6f$export$b8af8fc636c3246c","state","mode","active_player","AI_interval_speed","AI_interval","config","current_game_state","game_state","$44eb225e577f5b6f$var$GameManager","$96dc69330f4006e6$export$9099ad97b570f7c","debugDetail","detail","console","log","$ea71504a96aa2c34$export$17a16887dec63cf9","value","suit","name","t","power","$11c5be9bc12426bd$export$20ffe41b7193b8a9","PICKUP_DECK","DISCARD_DECK","starting_hand_size","shufflePickUpDeck","shuffle","removeCardByIndexFromPickupDeck","insertCardAtIndexToPickupDeck","deck","get","insert","r","card","$221d047ad45c7871$export$9099ad97b570f7c","c","idx","Math","floor","random","getDiscardDeckSize","splice","removeCardByIndexFromDiscardDeck","removeFirstNCardsFromPickupDeck","num_cards","removeCardAtIndexFromDiscardDeck","insertCardAtIndexToDiscardDeck","insertToTopOfPickupDeck","unshift","insertToTopOfDiscardDeck","top_discard_card","players","player","p","cards","addCards","$11c5be9bc12426bd$var$DeckManager","$fcc0e00e4d763446$export$956e9873de14b510","$fcc0e00e4d763446$export$40ccb1040d2dac1b","$fcc0e00e4d763446$export$27ce1dfb0d23c5d9","$fcc0e00e4d763446$export$2d2708adb0aa9def","$fcc0e00e4d763446$export$1589473b83eaf132","$fcc0e00e4d763446$export$4cdadcb89c669fa","$fcc0e00e4d763446$export$25d3d9ee17553480","$fcc0e00e4d763446$export$20f31bf76ab0c0e7","$fcc0e00e4d763446$export$830a9b82a0e63fd4","$fcc0e00e4d763446$export$c917356a60ebc691","$fcc0e00e4d763446$export$1a317aa94554970c","$24933b1da9407316$export$6102449f17319186","num_players","player_list","current_player_idx","previous_player_idx","next_player_idx","play_direction","determineNextPlayerIdx","next_idx","determinePreviousPlayerIdx","prev_idx","player_configs","el","is_human","status","play_state","action","effect","push","concat","cardIdx","findIndex","error","includes","action_state","effect_state","$7c59cbfcc26091bc$export$271aa840ccfeca27","init","resetStatus","current_player","getEffectState","updatePlayState","getPlayerName","$24933b1da9407316$var$PlayerManager","$f2685e675d063702$export$ee39aefc8ac7973d","pickup_deck_el","discard_deck_el","updates_board_el","card_w","card_h","createCardHTML","is_facing","$f2685e675d063702$var$ViewManager","$55da759ecb6a12c7$export$9099ad97b570f7c","drawPlayerDecks","getPlayerList","getCurrentCards","deck_el","getPlayerEl","querySelector","innerHTML","insertAdjacentHTML","createListedCardHTML","getIsHuman","$37667b8e8e4c1d3e$export$9099ad97b570f7c","drawDiscardDeck","getDiscardDeck","$01347e696b0863a6$export$9099ad97b570f7c","updateView","$d595dc2187788df7$export$9099ad97b570f7c","outputToBoard","message","update_board","getGameUpdateBoard","scrollTop","scrollHeight","$79c68744ad1dbe41$export$9099ad97b570f7c","hasWinConditionBeenReached","num_cards_remaining","getCurrentActivePlayer","getHandSize","$22c34f0582336759$export$9099ad97b570f7c","applyPowerEffect","current_active_player","current_next_player","getCurrentNextPlayer","changePlayDirection","updateEffectState","$3a1acf0ae79c7054$export$9099ad97b570f7c","checkLegalPlayableMove","current_top_card","getDiscardDeckTopCard","$bab83c85d8f47566$export$9099ad97b570f7c","handlePlayCard","removeCard","updateActionState","$6b4c28b72f88fbe8$export$9099ad97b570f7c","playCard","$bc43d0b206867b4f$export$9099ad97b570f7c","onAIPlayerCardSelect","playable_cards","available_power_cards","filter","playing_card","$cf0afc8e2e8bb490$export$9099ad97b570f7c","$e558c350ebdab41d$export$9099ad97b570f7c","pickupCardFromDeck","top_card","addCard","getPickupDeckSize","swapDecks","$1ba684bd78fb2fd1$export$9099ad97b570f7c","handleCardPickup","e","$e8f908290affb03c$export$9099ad97b570f7c","chooseAIPlayerActionChoice","Players","$3ae67b45eb8c2a3d$export$9099ad97b570f7c","handleTurnBegin","$8c048b4042a1c08f$export$9099ad97b570f7c","window","setTimeout","resolvePowerEffectState","currentPlayer","c1","$14b6c1ffc22f158c$export$9099ad97b570f7c","onEndTurn","setNextActivePlayer","endTurn","getActionState","Deck","$7608e95f96f71c74$export$9099ad97b570f7c","onHumanPlayerCardSelect","event","selection","target","parentNode","srcElement","className","getAttribute","Game","View","document","addEventListener","remove","getElementById","createPlayers","prepareDeck","dealCards","find"],"version":3,"file":"index.5eb5f1fb.js.map"}