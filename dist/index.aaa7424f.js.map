{"mappings":"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","sources":["src/js/Utilities/loop.js","src/js/Utilities/updateObject.js","src/js/Managers/game.js","src/js/Utilities/debugDetail.js","src/js/Cards/powers.js","src/js/Cards/cards.js","src/js/Managers/deck.js","src/js/Player/player_states.js","src/js/Managers/player.js","src/js/Player/player.js","src/js/Managers/view.js","src/js/View/drawPlayerDecks.js","src/js/View/drawDiscardDeck.js","src/js/View/updateView.js","src/js/View/outputToBoard.js","src/js/Gameplay/End/hasWinConditionBeenReached.js","src/js/Gameplay/Powers/applyPowerEffect.js","src/js/Gameplay/Play/checkLegalPlayableMove.js","src/js/Gameplay/Play/handlePlayCard.js","src/js/Gameplay/Play/playCard.js","src/js/Gameplay/Play/onAIPlayerCardSelect.js","src/js/Gameplay/Pickup/pickupCardFromDeck.js","src/js/Gameplay/Pickup/handleCardPickup.js","src/js/Gameplay/Begin/chooseAIPlayerActionChoice.js","src/js/Gameplay/Begin/handleTurnBegin.js","src/js/Gameplay/Powers/resolvePowerEffectState.js","src/js/Gameplay/End/onEndTurn.js","src/js/Gameplay/End/endTurn.js","src/js/Gameplay/Play/onHumanPlayerCardSelect.js","src/js/index.js"],"sourcesContent":["/**\n * \n * @param {*} array: array to loop over\n * @param {*} cb: callback for each loop\n * @param {int} dir: direction of loop, 1 for inc, -1 for decre\n * @param {*} scope \n * @returns \n */\nexport default function loop(array, cb, dir = 1, scope = undefined) {\n    if (\n        !Array.isArray(array) &&\n        // eslint-disable-next-line no-prototype-builtins\n        !NodeList.prototype.isPrototypeOf(array) &&\n        // eslint-disable-next-line no-prototype-builtins\n        !HTMLCollection.prototype.isPrototypeOf(array)\n    )\n        return;\n\n    let i = dir == 1 ? 0 : array.length - 1,\n        l = dir == 1 ? array.length : 0;\n\n    for (i; (dir == 1 ? i < l : i > l); (dir == 1 ? i++ : i--)) {\n        cb.call(scope, array[i], i);\n    }\n}\n","export const updateObject = (oldObject, newObj) => {\n    for (const key in newObj) {\n        if (Object.hasOwnProperty.call(newObj, key)) {\n            oldObject[key] = newObj[key];\n        }\n    }\n}","import { updateObject } from \"./../Utilities/updateObject\";\n\n// * Manage the running of the game, linking components\nconst GameManager = () => {\n\n    const state = {\n        mode: \"DEBUG\",\n\n        active_player: null,\n        AI_interval_speed: null,\n        AI_interval: null,\n\n        // current_game_state: \"INIT\"\n\n    }\n\n    // * Initialise the game world with a new config\n    const init = (config = {}) => {\n        updateObject(state, config);\n    }\n\n    // * Get current game state\n    const getCurrentGameState = () => {\n        return state.current_game_state;\n    }\n\n    // * Set current game state\n    const setCurrentGameState = (game_state) => {\n        updateObject(state, {\n            current_game_state: game_state\n        })\n    }\n\n    return {\n        init,\n        getCurrentGameState,\n        setCurrentGameState,\n    }\n\n}\n\nexport const Game = GameManager();","\n// * Output detail - TODO: Make better view\nexport default debugDetail = detail => console.log(detail);","export const PICKUP_2 = \"PICKUP_2\";\nexport const PICKUP_7 = \"PICKUP_7\";\nexport const MISS_TURN = \"MISS_TURN\";\nexport const ANOTHER_TURN = \"ANOTHER_TURN\";\nexport const CHANGE_DIRECTION = \"CHANGE_DIRECTION\";\nexport const CHANGE_SUIT = \"CHANGE_SUIT\";","import * as POWERS from \"./powers\";\n\nexport const cards = [\n    { value: \"A\", suit: \"hearts\", name: \"Ace of Hearts\", t: 2, l: 0, power: POWERS.CHANGE_SUIT }, //4\n    { value: 13, suit: \"hearts\", name: \"King of Hearts\", t: 2, l: 12, power: POWERS.ANOTHER_TURN },\n    { value: 12, suit: \"hearts\", name: \"Queen of Hearts\", t: 2, l: 11 },\n    { value: 11, suit: \"hearts\", name: \"Jack of Hearts\", t: 2, l: 10 },\n    { value: 10, suit: \"hearts\", name: \"10 of Hearts\", t: 2, l: 9, power: POWERS.CHANGE_DIRECTION }, //2\n    { value: 9, suit: \"hearts\", name: \"9 of Hearts\", t: 2, l: 8 },\n    { value: 8, suit: \"hearts\", name: \"8 of Hearts\", t: 2, l: 7, power: POWERS.MISS_TURN },\n    { value: 7, suit: \"hearts\", name: \"7 of Hearts\", t: 2, l: 6 },\n    { value: 6, suit: \"hearts\", name: \"6 of Hearts\", t: 2, l: 5 },\n    { value: 5, suit: \"hearts\", name: \"5 of Hearts\", t: 2, l: 4 },\n    { value: 4, suit: \"hearts\", name: \"4 of Hearts\", t: 2, l: 3 },\n    { value: 3, suit: \"hearts\", name: \"3 of Hearts\", t: 2, l: 2 },\n    { value: 2, suit: \"hearts\", name: \"2 of Hearts\", t: 2, l: 1, power: POWERS.PICKUP_2 },\n    { value: \"A\", suit: \"clubs\", name: \"Ace of Clubs\", t: 0, l: 0, power: POWERS.CHANGE_SUIT }, //4\n    { value: 13, suit: \"clubs\", name: \"King of Clubs\", t: 0, l: 12, power: POWERS.ANOTHER_TURN },\n    { value: 12, suit: \"clubs\", name: \"Queen of Clubs\", t: 0, l: 11 },\n    { value: 11, suit: \"clubs\", name: \"Jack of Clubs\", t: 0, l: 10, power: POWERS.PICKUP_7 },\n    { value: 10, suit: \"clubs\", name: \"10 of Clubs\", t: 0, l: 9, power: POWERS.CHANGE_DIRECTION }, //2\n    { value: 9, suit: \"clubs\", name: \"9 of Clubs\", t: 0, l: 8 },\n    { value: 8, suit: \"clubs\", name: \"8 of Clubs\", t: 0, l: 7, power: POWERS.MISS_TURN },\n    { value: 7, suit: \"clubs\", name: \"7 of Clubs\", t: 0, l: 6 },\n    { value: 6, suit: \"clubs\", name: \"6 of Clubs\", t: 0, l: 5 },\n    { value: 5, suit: \"clubs\", name: \"5 of Clubs\", t: 0, l: 4 },\n    { value: 4, suit: \"clubs\", name: \"4 of Clubs\", t: 0, l: 3 },\n    { value: 3, suit: \"clubs\", name: \"3 of Clubs\", t: 0, l: 2 },\n    { value: 2, suit: \"clubs\", name: \"2 of Clubs\", t: 0, l: 1, power: POWERS.PICKUP_2 },\n    { value: \"A\", suit: \"diamonds\", name: \"Ace of Diamonds\", t: 1, l: 0, power: POWERS.CHANGE_SUIT }, //4\n    { value: 13, suit: \"diamonds\", name: \"King of Diamonds\", t: 1, l: 12, power: POWERS.ANOTHER_TURN },\n    { value: 12, suit: \"diamonds\", name: \"Queen of Diamonds\", t: 1, l: 11 },\n    { value: 11, suit: \"diamonds\", name: \"Jack of Diamonds\", t: 1, l: 10 },\n    { value: 10, suit: \"diamonds\", name: \"10 of Diamonds\", t: 1, l: 9, power: POWERS.CHANGE_DIRECTION }, //2\n    { value: 9, suit: \"diamonds\", name: \"9 of Diamonds\", t: 1, l: 8 },\n    { value: 8, suit: \"diamonds\", name: \"8 of Diamonds\", t: 1, l: 7, power: POWERS.MISS_TURN },\n    { value: 7, suit: \"diamonds\", name: \"7 of Diamonds\", t: 1, l: 6 },\n    { value: 6, suit: \"diamonds\", name: \"6 of Diamonds\", t: 1, l: 5 },\n    { value: 5, suit: \"diamonds\", name: \"5 of Diamonds\", t: 1, l: 4 },\n    { value: 4, suit: \"diamonds\", name: \"4 of Diamonds\", t: 1, l: 3 },\n    { value: 3, suit: \"diamonds\", name: \"3 of Diamonds\", t: 1, l: 2 },\n    { value: 2, suit: \"diamonds\", name: \"2 of Diamonds\", t: 1, l: 1, power: POWERS.PICKUP_2 },\n    { value: \"A\", suit: \"spades\", name: \"Ace of Spades\", t: 3, l: 0, power: POWERS.CHANGE_SUIT }, //4\n    { value: 13, suit: \"spades\", name: \"King of Spades\", t: 3, l: 12, power: POWERS.ANOTHER_TURN },\n    { value: 12, suit: \"spades\", name: \"Queen of Spades\", t: 3, l: 11 },\n    { value: 11, suit: \"spades\", name: \"Jack of Spades\", t: 3, l: 10, power: POWERS.PICKUP_7 },\n    { value: 10, suit: \"spades\", name: \"10 of Spades\", t: 3, l: 9, power: POWERS.CHANGE_DIRECTION }, //2\n    { value: 9, suit: \"spades\", name: \"9 of Spades\", t: 3, l: 8 },\n    { value: 8, suit: \"spades\", name: \"8 of Spades\", t: 3, l: 7, power: POWERS.MISS_TURN },\n    { value: 7, suit: \"spades\", name: \"7 of Spades\", t: 3, l: 6 },\n    { value: 6, suit: \"spades\", name: \"6 of Spades\", t: 3, l: 5 },\n    { value: 5, suit: \"spades\", name: \"5 of Spades\", t: 3, l: 4 },\n    { value: 4, suit: \"spades\", name: \"4 of Spades\", t: 3, l: 3 },\n    { value: 3, suit: \"spades\", name: \"3 of Spades\", t: 3, l: 2 },\n    { value: 2, suit: \"spades\", name: \"2 of Spades\", t: 3, l: 1, power: POWERS.PICKUP_2 },\n];","import debugDetail from \"../Utilities/debugDetail\";\nimport { cards } from \"./../Cards/cards\";\nimport loop from \"./../Utilities/loop\";\n\nimport { updateObject } from \"./../Utilities/updateObject\";\n\nconst DeckManager = () => {\n\n    const PICKUP_DECK = cards;\n\n    const DISCARD_DECK = [];\n\n    const state = {\n        starting_hand_size: 7,\n    }\n\n    const init = (config) => {\n        updateObject(state, config);\n    }\n\n    const prepareDeck = () => {\n        // * Shuffle Pickup deck\n        shufflePickUpDeck();\n\n        // * Move top card from Pickup to Discard Deck\n        insertCardAtIndexToDiscardDeck(0, removeCardByIndexFromPickupDeck(0));\n    }\n\n    // * Shuffle the deck\n    const shufflePickUpDeck = () => {\n        shuffle(\n            PICKUP_DECK,\n            removeCardByIndexFromPickupDeck,\n            insertCardAtIndexToPickupDeck\n        );\n    }\n\n    const shuffleDiscardDeck = () => {\n        shuffle(\n            DISCARD_DECK,\n            removeCardByIndexFromDiscardDeck,\n            insertCardAtIndexToDiscardDeck\n        );\n    }\n\n    const shuffle = (deck, get, insert) => {\n        let r, card;\n\n        // Create a copy of the cardArray to shuffle (Works by swapping the last card with a randomly selected card)\n        loop(deck, (c, idx) => {\n            // Get a random Integer\n            r = Math.floor(Math.random() * idx);\n            // Get the next last card in the Store.deck\n            card = get(idx - 1);\n            // Whatever card was initially chosen, place a randomly selected one there now\n            insert((idx - 1), get(r));\n            // Place the card that was initially chosen in the position of the randomly selected card\n            insert([r], card);\n        }, -1)\n    }\n\n    // * Deal the cards to the players\n    const dealCards = (players) => {\n        loop(players, (player, p) => {\n            let cards = removeFirstNCardsFromPickupDeck(state.starting_hand_size);\n\n            player.addCards(cards);\n        });\n    }\n\n    const getPickupDeck = () => {\n        return PICKUP_DECK;\n    }\n\n    const getPickupDeckTopCard = () => {\n        return PICKUP_DECK[0];\n    }\n\n    const getPickupDeckSize = () => {\n        return PICKUP_DECK.length;\n    }\n\n    const getDiscardDeck = () => {\n        return DISCARD_DECK;\n    }\n\n    const getDiscardDeckTopCard = () => {\n        return DISCARD_DECK[0];\n    }\n\n    const getDiscardDeckSize = () => {\n        return DISCARD_DECK.length;\n    }\n\n    const removeCardByIndexFromPickupDeck = (idx) => {\n        return PICKUP_DECK.splice(idx, 1)[0];\n    }\n\n    const removeCardByIndexFromDiscardDeck = (idx) => {\n        return DISCARD_DECK.splice(idx, 1)[0];\n    }\n\n    const removeFirstNCardsFromPickupDeck = (num_cards) => {\n        return PICKUP_DECK.splice(0, num_cards);\n    }\n\n    const removeFirstNCardsFromDiscardDeck = (num_cards) => {\n        return DISCARD_DECK.splice(0, num_cards);\n    }\n\n    const removeCardAtIndexFromPickupDeck = (idx) => {\n        return PICKUP_DECK.splice(idx, 1)[0];\n    }\n\n    const removeCardAtIndexFromDiscardDeck = (idx) => {\n        return DISCARD_DECK.splice(idx, 1)[0];\n    }\n\n    const insertCardAtIndexToPickupDeck = (idx, card) => {\n        PICKUP_DECK.splice(idx, 0, card);\n    }\n\n    const insertCardAtIndexToDiscardDeck = (idx, card) => {\n        DISCARD_DECK.splice(idx, 0, card);\n    }\n\n    const insertToTopOfPickupDeck = (card) => {\n        PICKUP_DECK.unshift(card);\n    }\n\n    const insertToTopOfDiscardDeck = (card) => {\n        DISCARD_DECK.unshift(card);\n    }\n\n    const swapDecks = () => {\n        debugDetail(`Refilling Pickup Deck from Discard Deck`);\n\n        // TODO - What if no cards are left?\n\n        // * Move all discarded cards to pickup deck, leaving last discarded card in discard pile\n        const top_discard_card = removeCardAtIndexFromDiscardDeck(0);\n\n        // * loop through remaining discard deck and add to pickup deck\n        for (let idx = 0; idx < getDiscardDeckSize(); idx++) {\n            insertToTopOfPickupDeck(removeCardByIndexFromDiscardDeck(idx));\n        }\n\n        // * add initial discarded card back to discard pile\n        insertToTopOfDiscardDeck(top_discard_card);\n    }\n\n    return {\n        init,\n        prepareDeck,\n\n        getPickupDeck,\n        getPickupDeckSize,\n        getPickupDeckTopCard,\n        removeCardByIndexFromPickupDeck,\n        removeFirstNCardsFromPickupDeck,\n        removeCardAtIndexFromPickupDeck,\n        insertCardAtIndexToPickupDeck,\n        insertToTopOfPickupDeck,\n\n        getDiscardDeck,\n        getDiscardDeckSize,\n        getDiscardDeckTopCard,\n        removeCardByIndexFromDiscardDeck,\n        removeFirstNCardsFromDiscardDeck,\n        removeCardAtIndexFromDiscardDeck,\n        insertCardAtIndexToDiscardDeck,\n        insertToTopOfDiscardDeck,\n\n        shufflePickUpDeck,\n        shuffleDiscardDeck,\n\n        swapDecks,\n\n        dealCards,\n    }\n\n}\n\nexport const Deck = DeckManager();\n","export const IDLE = \"IDLE\";\nexport const TO_PLAY = \"TO_PLAY\";\nexport const HAS_PLAYED = \"HAS_PLAYED\";\n\nexport const ACTION_DID_PICKUP = \"DID_PICKUP\";\nexport const ACTION_DID_PUTDOWN = \"DID_PUTDOWN\";\nexport const ACTION_NO_ACTION = \"NO_ACTION\";\n\nexport const EFFECT_MUST_PICK_2 = \"MUST_PICK_2\";\nexport const EFFECT_MUST_PICK_7 = \"MUST_PICK_7\";\nexport const EFFECT_MUST_MISS_TURN = \"MUST_MISS_TURN\";\nexport const EFFECT_ANOTHER_TURN = \"EFFECT_ANOTHER_TURN\";\nexport const EFFECT_NO_EFFECT = \"EFFECT_NO_EFFECT\";","import { updateObject } from \"./../Utilities/updateObject\";\nimport { Player } from \"../Player/player\";\nimport debugDetail from \"../Utilities/debugDetail\";\nimport * as PLAYER_STATES from \"../Player/player_states\";\n\nimport loop from \"../Utilities/loop\";\n\nconst PlayerManager = () => {\n\n    const state = {\n        num_players: 4,\n        player_list: [],\n        current_player_idx: 0,\n        previous_player_idx: null,\n        next_player_idx: null,\n        play_direction: 1,\n    }\n\n    const init = (config) => {\n        updateObject(state, config);\n\n        state.previous_player_idx = determinePreviousPlayerIdx();\n        state.next_player_idx = determineNextPlayerIdx();\n    }\n\n    const determineNextPlayerIdx = () => {\n        let next_idx = state.current_player_idx + state.play_direction;\n\n        return next_idx < 0 ? state.num_players - 1 : next_idx >= state.num_players ? 0 : next_idx;\n    }\n\n    const determinePreviousPlayerIdx = () => {\n        let prev_idx = state.current_player_idx - state.play_direction;\n\n        return prev_idx < 0 ? state.num_players - 1 : prev_idx >= state.num_players ? 0 : prev_idx;\n    }\n\n    const createPlayers = (player_configs) => {\n\n        loop(player_configs, (config) => {\n            let player = Player();\n\n            player.init({\n                is_human: config.is_human,\n                name: config.name,\n                el: config.el\n            });\n\n            state.player_list.push(player);\n        });\n    }\n\n    const setNextActivePlayer = () => {\n        // * set the next player to current\n        state.current_player_idx = state.next_player_idx;\n\n\n        // * current idx now becomes previous idx\n        state.previous_player_idx = determinePreviousPlayerIdx();\n\n        // * Get and update new previous\n        let previous_player = state.player_list[state.previous_player_idx];\n        // * Reset to idle\n        previous_player.resetStatus();\n\n\n        // * next player now becomes next + (1 || -1)\n        state.next_player_idx = determineNextPlayerIdx();\n\n\n        // * Get and update new current player\n        let current_player = state.player_list[state.current_player_idx];\n        // * Ensure no effects are in place\n        if (current_player.getEffectState() === PLAYER_STATES.EFFECT_NO_EFFECT) {\n            // * unaffected, normal play\n            current_player.updatePlayState(PLAYER_STATES.TO_PLAY);\n        } else {\n            // * has been affected\n        }\n\n        debugDetail(`Current active player is now: ${current_player.getPlayerName()}`);\n    }\n\n    const getCurrentActivePlayer = () => {\n        return state.player_list[state.current_player_idx];\n    }\n\n    const getCurrentActivePlayerIdx = () => {\n        return state.current_player_idx;\n    }\n\n    const getCurrentNextPlayer = () => {\n        return state.player_list[state.next_player_idx];\n    }\n\n    const getCurrentNextPlayerIdx = () => {\n        return state.next_player_idx;\n    }\n\n    const getCurrentPreviousPlayer = () => {\n        return state.player_list[state.previous_player_idx];\n    }\n\n    const getCurrentPreviousPlayerIdx = () => {\n        return state.previous_player_idx;\n    }\n\n    const getPlayerList = () => {\n        return state.player_list;\n    }\n\n    const changePlayDirection = () => {\n        state.play_direction = state.play_direction * -1;\n\n        // * set next to previous player\n        state.next_player_idx = state.previous_player_idx;\n    }\n\n    return {\n        init,\n        createPlayers,\n        setNextActivePlayer,\n        getCurrentActivePlayer,\n        getCurrentActivePlayerIdx,\n        getCurrentNextPlayer,\n        getCurrentNextPlayerIdx,\n        getCurrentPreviousPlayer,\n        getCurrentPreviousPlayerIdx,\n        getPlayerList,\n        changePlayDirection,\n    }\n\n}\n\nexport const Players = PlayerManager();","import debugDetail from \"../Utilities/debugDetail\";\nimport { updateObject } from \"./../Utilities/updateObject\";\n\nimport * as PLAYER_STATES from \"./player_states\";\n\nexport const Player = () => {\n    const state = {\n        name: null,\n        deck: [],\n        el: null,\n        is_human: false,\n\n        status: {\n            play_state: PLAYER_STATES.IDLE,\n            action: PLAYER_STATES.ACTION_NO_ACTION,\n            effect: PLAYER_STATES.EFFECT_NO_EFFECT,\n        }\n    }\n\n    // * Initialise the player with a config object\n    const init = (config) => {\n        updateObject(state, config);\n    }\n\n    // * Add a card to the player deck\n    const addCard = (card) => {\n        state.deck.push(card);\n    }\n\n    // * Add cards to the player deck\n    const addCards = (cards) => {\n        state.deck = state.deck.concat(cards);\n    }\n\n    // * Remove a card at index\n    const removeCardAtIndex = (idx) => {\n        state.deck.splice(idx, 1)[0];\n    }\n\n    // * Remove a number of cards starting at index\n    const removeCards = (idx, num_cards) => {\n        state.deck.splice(idx, num_cards);\n    }\n\n    // * Remove a selected card by value/suit\n    const removeCard = ({ value, suit }) => {\n        let cardIdx = state.deck.findIndex((card) => {\n            return card.value == value && card.suit == suit;\n        });\n\n        if (cardIdx < 0) {\n            console.error(\"Selected player card not found\");\n        }\n\n        return state.deck.splice(cardIdx, 1)[0];\n    }\n\n    // * Get the players name\n    const getPlayerName = () => {\n        return state.name;\n    }\n\n    // * Get is the player human\n    const getIsHuman = () => {\n        return state.is_human;\n    }\n\n    // * Get current cards\n    const getCurrentCards = () => {\n        return state.deck;\n    }\n\n    // * Get current hand size\n    const getHandSize = () => {\n        return state.deck.length;\n    }\n\n    // * Reset the player status\n    const resetStatus = () => {\n        state.status = {\n            play_state: PLAYER_STATES.IDLE,\n            action: PLAYER_STATES.ACTION_NO_ACTION,\n            effect: PLAYER_STATES.EFFECT_NO_EFFECT,\n        };\n    }\n\n    // * Get the full player status\n    const getStatus = () => {\n        return state.status;\n    }\n\n    // * update the play state\n    const updatePlayState = (play_state) => {\n        // * Check acceptable state provided\n        if (![\n            PLAYER_STATES.IDLE,\n            PLAYER_STATES.TO_PLAY,\n            PLAYER_STATES.HAS_PLAYED\n        ].includes(play_state)) {\n            debugDetail(`${state.name} [state.play_state] provided unacceptable state: ${play_state}`);\n        }\n\n        state.status.play_state = play_state;\n        debugDetail(`${state.name} [state.play_state] is now ${play_state}`);\n    }\n\n    // * get the players current play state\n    const getPlayState = () => {\n        return state.status.play_state;\n    }\n\n    // * update the action state\n    const updateActionState = (action_state) => {\n        // * Check acceptable state provided\n        if (![\n            PLAYER_STATES.ACTION_DID_PICKUP,\n            PLAYER_STATES.ACTION_DID_PUTDOWN,\n            PLAYER_STATES.ACTION_NO_ACTION,\n        ].includes(action_state)) {\n            debugDetail(`${state.name} [state.action_state] provided unacceptable state: ${action_state}`);\n        }\n        state.status.action = action_state;\n        debugDetail(`${state.name} [state.action] is now ${action_state}`);\n    }\n\n    // * get the players action state\n    const getActionState = () => {\n        return state.status.action;\n    }\n\n    // * update the effect state\n    const updateEffectState = (effect_state) => {\n        // * Check acceptable state provided\n        if (![\n            PLAYER_STATES.EFFECT_MUST_PICK_2,\n            PLAYER_STATES.EFFECT_MUST_PICK_7,\n            PLAYER_STATES.EFFECT_MUST_MISS_TURN,\n            PLAYER_STATES.EFFECT_ANOTHER_TURN,\n            PLAYER_STATES.EFFECT_NO_EFFECT,\n        ].includes(effect_state)) {\n            debugDetail(`${state.name} [state.effect_state] provided unacceptable state: ${effect_state}`);\n        }\n        state.status.effect = effect_state;\n        debugDetail(`${state.name} [state.effect] is now ${effect_state}`);\n    }\n\n    // * get the players current effect state\n    const getEffectState = () => {\n        return state.status.effect;\n    }\n\n    const getPlayerEl = () => {\n        return state.el;\n    }\n\n    return {\n        init,\n\n        addCard,\n        addCards,\n\n        removeCard,\n        removeCardAtIndex,\n        removeCards,\n\n        getPlayerName,\n        getCurrentCards,\n        getIsHuman,\n        getHandSize,\n        getPlayerEl,\n\n        resetStatus,\n        getStatus,\n\n        updatePlayState,\n        getPlayState,\n        updateActionState,\n        getActionState,\n        updateEffectState,\n        getEffectState,\n    }\n}","import { updateObject } from \"./../Utilities/updateObject\";\n\nconst ViewManager = () => {\n\n    const state = {\n        pickup_deck_el: null,\n        discard_deck_el: null,\n        updates_board_el: null,\n\n        card_w: 59,\n        card_h: 90,\n    }\n\n    const init = (config = {}) => {\n        updateObject(state, config);\n    }\n\n    const createCardHTML = (card, is_facing) => {\n        return (\n            `<img class=\"${is_facing ? \"face_up\" : \"face_down\"}\" style=\"background-position: -${card.l * state.card_w}px -${card.t * state.card_h}px;\"/>`\n        )\n    }\n\n    const createListedCardHTML = (card, is_facing) => {\n        return (\n            `<li class=\"card\" data-v=\"${card.value}\" data-s=\"${card.suit}\">\n                ${createCardHTML(card, is_facing)}\n            </li>`\n        );\n    }\n\n    const getPickupDeck = () => {\n        return state.pickup_deck_el;\n    }\n\n    const getDiscardDeck = () => {\n        return state.discard_deck_el;\n    }\n\n    const getGameUpdateBoard = () => {\n        return state.updates_board_el;\n    }\n\n    return {\n        init,\n\n        createListedCardHTML,\n        createCardHTML,\n\n        getPickupDeck,\n        getDiscardDeck,\n\n        getGameUpdateBoard,\n    }\n}\n\nexport const View = ViewManager();","import loop from \"./../Utilities/loop\";\nimport { Players, View } from \"./../Managers/managers\";\n\n// * Define player decks\nexport default drawPlayerDecks = () => {\n\n    loop(Players.getPlayerList(), (player) => {\n        const deck = player.getCurrentCards();\n\n        // * get deck element\n        const deck_el = player.getPlayerEl().querySelector('.card_list');\n\n        // * remove HTML\n        deck_el.innerHTML = \"\";\n\n        loop(deck, (card) => {\n            deck_el.insertAdjacentHTML(\n                \"beforeend\",\n                View.createListedCardHTML(card, player.getIsHuman())\n            );\n        });\n    });\n}","import { Deck, View } from \"./../Managers/managers\";\n\nexport default drawDiscardDeck = () => {\n\n    let card = Deck.getDiscardDeck()[0];\n    View.getDiscardDeck().innerHTML = View.createCardHTML(card, true);\n}","import drawPlayerDecks from \"./drawPlayerDecks\";\nimport drawDiscardDeck from \"./drawDiscardDeck\";\n\nexport default updateView = () => {\n\n    // * Draw player decks\n    drawPlayerDecks();\n    // * Draw discard decks\n    drawDiscardDeck();\n}","import { View } from \"./../Managers/managers\";\n\n// * Output message to the game board\nexport default outputToBoard = (message) => {\n\n    const update_board = View.getGameUpdateBoard();\n\n    update_board.insertAdjacentHTML(\"beforeend\", `<p>${message}</p>`);\n    update_board.scrollTop = update_board.scrollHeight;\n}","import { Players } from \"../../Managers/managers\";\nimport debugDetail from \"../../Utilities/debugDetail\";\n\n// * Test if a win condition has been reached\nexport default hasWinConditionBeenReached = () => {\n\n    debugDetail(`[hasWinConditionBeenReached] Checking win condition`);\n\n    // * Current player has won if they have no cards left\n    let num_cards_remaining = Players.getCurrentActivePlayer().getHandSize();\n\n    debugDetail(`[hasWinConditionBeenReached] Player has ${num_cards_remaining} cards remaining`);\n\n    // * To win there has to be no cards remaining\n    // TODO - last placed card should not be a power card and player needs to pick up\n    return num_cards_remaining === 0;\n}","import * as POWERS from \"./../../Cards/powers\";\nimport * as PLAYER_STATES from \"./../../Player/player_states\";\nimport outputToBoard from \"../../View/outputToBoard\";\nimport { Players } from \"./../../Managers/managers\";\n\n// * Apply power effects from power card\nexport default applyPowerEffect = (power) => {\n\n    const current_active_player = Players.getCurrentActivePlayer();\n    const current_next_player = Players.getCurrentNextPlayer();\n\n    switch (power) {\n        case POWERS.CHANGE_DIRECTION:\n\n            // * Change play direction\n            outputToBoard(`Direction of play is reversed!`);\n            Players.changePlayDirection();\n\n            break;\n\n        case POWERS.CHANGE_SUIT:\n\n            // * Change playable suit\n            outputToBoard(`New suit chosen! [TODO]`);\n            // TODO\n            break;\n\n        case POWERS.ANOTHER_TURN:\n\n            // * Player has another go\n            outputToBoard(`${current_active_player.getPlayerName()} to take another turn!`);\n            current_active_player.updateEffectState(PLAYER_STATES.EFFECT_ANOTHER_TURN);\n            break;\n\n        case POWERS.MISS_TURN:\n\n            // * Next player misses turn\n            outputToBoard(`${current_next_player.getPlayerName()} to miss a turn!`);\n            current_next_player.updateEffectState(PLAYER_STATES.EFFECT_MUST_MISS_TURN);\n            break;\n\n        case POWERS.PICKUP_2:\n\n            // * Next player must pickup 2\n            outputToBoard(`${current_next_player.getPlayerName()} must pick up 2 cards!`);\n            current_next_player.updateEffectState(PLAYER_STATES.EFFECT_MUST_PICK_2);\n            break;\n\n        case POWERS.PICKUP_7:\n\n            // * Next player must pickup 7\n            outputToBoard(`${current_next_player.getPlayerName()} must pick up 7 cards!`);\n            current_next_player.updateEffectState(PLAYER_STATES.EFFECT_MUST_PICK_7);\n            break;\n\n        default:\n\n            debugDetail(`[applyPowerEffect] Unknown power applied! ${power}`);\n    }\n}","import { Deck } from \"./../../Managers/managers\";\n\nexport default checkLegalPlayableMove = ({ value, suit }) => {\n\n    // * get current card attempting to play upon\n    const current_top_card = Deck.getDiscardDeckTopCard();\n\n    // * playable card must be of the same suit or of the same value\n    return (value == current_top_card.value) || (suit == current_top_card.suit);\n}","import { Deck, Players } from \"./../../Managers/managers\";\nimport debugDetail from \"../../Utilities/debugDetail\";\n\nimport * as PLAYER_STATES from \"./../../Player/player_states\";\n\n// * Play the given card\nexport default handlePlayCard = ({ value, suit }) => {\n\n    // * get card from player hand\n    let current_player = Players.getCurrentActivePlayer();\n\n    const card = current_player.removeCard({\n        value,\n        suit\n    });\n\n    debugDetail(`[playCard] Playing card: ${card.name}`);\n\n    // * place card to discard deck\n    Deck.insertToTopOfDiscardDeck(card);\n\n    current_player.updateActionState(PLAYER_STATES.ACTION_DID_PUTDOWN);\n\n    outputToBoard(`${current_player.getPlayerName()} has played the ${card.name}`);\n\n    updateView();\n}","import debugDetail from \"../../Utilities/debugDetail\";\nimport outputToBoard from \"../../View/outputToBoard\";\nimport checkLegalPlayableMove from \"./checkLegalPlayableMove\";\nimport handlePlayCard from \"./handlePlayCard\";\n\n// * Attempt to play a card\nexport default playCard = ({ value, suit }) => {\n\n    debugDetail(`[handlePlayCard] Attempting to play`);\n\n    // * Check whether card can be played\n    if (!checkLegalPlayableMove({ value, suit })) {\n        debugDetail(`[handlePlayCard] Card not playable`);\n        outputToBoard(`That card isn't playable!`);\n\n        // * card not playable\n        return false;\n    }\n\n    // * card is playable, so play it\n    handlePlayCard({ value, suit });\n\n    // * card is playable\n    return true;\n}\n","import debugDetail from \"../../Utilities/debugDetail\";\nimport playCard from \"./playCard\";\nimport endTurn from \"../End/endTurn\";\n\n// * Define AI Player Interactions\nexport default onAIPlayerCardSelect = (playable_cards) => {\n\n    // * AI Player select card from hand\n    debugDetail(`[onAIPlayerCardSelect] Playing a card from hand`);\n\n    // * Check if any of the cards are a power card\n    let available_power_cards = playable_cards.filter(function (card) {\n\n        return typeof card.power !== \"undefined\";\n    });\n\n    // * index of card choice\n    let playing_card = null;\n\n    // * if power cards available, we want to be more likely to selecting one of them\n    if (available_power_cards.length && Math.random() > 0.4) {\n\n        // * Select from the power card list\n        playing_card = available_power_cards[Math.floor(Math.random() * available_power_cards.length)];\n\n    } else {\n\n        // * select any random card\n        playing_card = playable_cards[Math.floor(Math.random() * playable_cards.length)];\n    }\n\n    playCard({\n        value: playing_card.value,\n        suit: playing_card.suit\n    });\n\n    endTurn();\n}","import { Players, Deck } from \"./../../Managers/managers\";\n\nimport updateView from \"../../View/updateView\";\n\nimport debugDetail from \"../../Utilities/debugDetail\";\nimport outputToBoard from \"../../View/outputToBoard\";\n\nimport * as PLAYER_STATES from \"./../../Player/player_states\";\n\nexport default pickupCardFromDeck = () => {\n\n    debugDetail(`[pickupCardFromDeck] Picking up card`);\n\n    // * get current player attempting pickup\n    let current_player = Players.getCurrentActivePlayer();\n\n    // * get pickup deck\n    let top_card = Deck.removeCardByIndexFromPickupDeck(0);\n\n    // * add picked up card to player deck\n    current_player.addCard(top_card);\n\n    debugDetail(`[pickupCardFromDeck] Picked up card: ${top_card.name}`);\n\n    // * if deck is now empty, then swap decks\n    if (Deck.getPickupDeckSize() <= 0) {\n        Deck.swapDecks();\n    }\n\n    // * Update the players action state\n    current_player.updateActionState(PLAYER_STATES.ACTION_DID_PICKUP);\n\n    outputToBoard(`${current_player.getPlayerName()} has picked up`);\n\n    // * redraw the view\n    updateView();\n}","import pickupCardFromDeck from \"./pickupCardFromDeck\";\nimport endTurn from \"../End/endTurn\";\n\nexport default handleCardPickup = (e) => {\n    pickupCardFromDeck();\n    endTurn();\n}","import debugDetail from \"../../Utilities/debugDetail\";\nimport checkLegalPlayableMove from \"../Play/checkLegalPlayableMove\";\nimport onAIPlayerCardSelect from \"../Play/onAIPlayerCardSelect\";\nimport handleCardPickup from \"../Pickup/handleCardPickup\";\n\n// * Handle AI making play choice\nexport default chooseAIPlayerActionChoice = () => {\n\n    // * Get current AI player\n    const current_AI_player = Players.getCurrentActivePlayer();\n\n    // * get players current hand\n    const current_hand = current_AI_player.getCurrentCards();\n\n    // * get legal playable cards from hand\n    const playable_cards = current_hand.filter((card) => {\n\n        return checkLegalPlayableMove(card);\n    });\n\n    debugDetail(`[chooseAIPlayerActionChoice] Number of playable cards: ${playable_cards.length}`);\n\n    // * if playable cards\n    if (playable_cards.length && Math.random() >= 0.3) {\n        // * more weighting to putting down cards than picking them up\n        // * choice based on random value\n\n        // * play a card\n        debugDetail(`[chooseAIPlayerActionChoice] Player has chosen to play a card`);\n        onAIPlayerCardSelect(playable_cards);\n    } else {\n\n        // * no playable cards, so has to pickup\n        debugDetail(`Player must pickup`);\n        handleCardPickup();\n    }\n}","import debugDetail from \"../../Utilities/debugDetail\";\nimport { Players } from \"./../../Managers/managers\";\n\nimport resolvePowerEffectState from \"../Powers/resolvePowerEffectState\";\nimport chooseAIPlayerActionChoice from \"../Begin/chooseAIPlayerActionChoice\";\n\nimport * as PLAYER_STATES from \"./../../Player/player_states\";\n\nexport default handleTurnBegin = () => {\n\n    // * Resolve any effects\n\n    let current_active_player = Players.getCurrentActivePlayer();\n\n    if (current_active_player.getEffectState() !== PLAYER_STATES.EFFECT_NO_EFFECT) {\n\n        debugDetail(`Current player is affected by ${current_active_player.getEffectState()}`);\n\n        resolvePowerEffectState(\n            current_active_player,\n            current_active_player.getEffectState()\n        );\n\n    } else {\n        // * no effect in play, continue as normal\n\n        outputToBoard(`${current_active_player.getPlayerName()} to play...`);\n\n        // * if AI\n        if (!current_active_player.getIsHuman()) {\n\n            debugDetail(`[chooseAIPlayerActionChoice] Player is thinking...`);\n            // * simulate player thinking before choice (effectively slow down game)\n            window.setTimeout(chooseAIPlayerActionChoice, 2000);\n        } else {\n            // * is human\n            // ... wait for player interaction\n        }\n    }\n}","import * as PLAYER_STATES from \"./../../Player/player_states\";\nimport { Players } from \"./../../Managers/managers\";\nimport debugDetail from \"../../Utilities/debugDetail\";\nimport handleTurnBegin from \"../Begin/handleTurnBegin\";\nimport endTurn from \"../End/endTurn\";\nimport pickupCardFromDeck from \"../Pickup/pickupCardFromDeck\";\n\n// * Resolve the power effect in place\nexport default resolvePowerEffectState = (currentPlayer, effect_state) => {\n\n    const current_active_player = Players.getCurrentActivePlayer();\n\n    switch (effect_state) {\n        case PLAYER_STATES.EFFECT_ANOTHER_TURN:\n\n            // * Player has another go\n            debugDetail(`[resolvePowerEffectState] Player taking another turn [TODO]`);\n            // * reset status\n            current_active_player.resetStatus();\n            current_active_player.updatePlayState(PLAYER_STATES.TO_PLAY);\n            handleTurnBegin();\n            break;\n\n        case PLAYER_STATES.EFFECT_MUST_MISS_TURN:\n\n            // * go straight to end turn\n            debugDetail(`[resolvePowerEffectState] Missing Turn`);\n            endTurn();\n            break;\n\n        case PLAYER_STATES.EFFECT_MUST_PICK_2:\n\n            // * Next player must pickup 2 then end turn\n            debugDetail(`[resolvePowerEffectState] Picking up 2 cards`);\n            for (let c = 0; c < 2; c++) {\n                pickupCardFromDeck();\n            }\n            endTurn();\n            break;\n\n        case PLAYER_STATES.EFFECT_MUST_PICK_7:\n\n            // * Next player must pickup 7 then end turn\n            for (let c = 0; c < 7; c++) {\n                pickupCardFromDeck();\n            }\n            endTurn();\n            break;\n\n        default:\n\n            debugDetail(`[resolvePowerEffectState] Unknown effect state applied! ${effect_state}`);\n    }\n}","import { Players } from \"./../../Managers/managers\";\nimport debugDetail from \"../../Utilities/debugDetail\";\n\nimport handleTurnBegin from \"../Begin/handleTurnBegin\";\n\nexport default onEndTurn = () => {\n\n    // * update current players\n    Players.setNextActivePlayer();\n\n    debugDetail(`[chooseAIPlayerActionChoice] It is now ${Players.getCurrentActivePlayer().getPlayerName()}s turn`);\n\n    // * begin next turn\n    handleTurnBegin();\n}","import { Players } from \"./../../Managers/managers\";\nimport debugDetail from \"../../Utilities/debugDetail\";\nimport outputToBoard from \"./../../View/outputToBoard\";\nimport hasWinConditionBeenReached from \"./hasWinConditionBeenReached\";\nimport applyPowerEffect from \"./../Powers/applyPowerEffect\";\nimport resolvePowerEffectState from \"./../Powers/resolvePowerEffectState\";\nimport onEndTurn from \"./onEndTurn\";\n\nimport * as PLAYER_STATES from \"./../../Player/player_states\";\n\n// * handle ending a turn\nexport default endTurn = () => {\n\n    // * resolve anything before confirm turn is ended\n\n    const current_player = Players.getCurrentActivePlayer();\n\n    current_player.updatePlayState(PLAYER_STATES.HAS_PLAYED);\n\n    debugDetail(`[endTurn] Ending turn...`);\n\n    debugDetail(`[endTurn] actionState of current player: ${current_player.getActionState()}`);\n\n    // * If player put a card down, then apply power if required\n    if (current_player.getActionState() === PLAYER_STATES.ACTION_DID_PUTDOWN) {\n\n        // * Player putdown a card, check if power card\n        const top_card = Deck.getDiscardDeckTopCard();\n\n        if (top_card.power) {\n\n            debugDetail(`[endTurn] Card putdown is a power card: ${top_card.power}`);\n            outputToBoard(`It's a power card!`);\n\n            // * Apply power effect\n            applyPowerEffect(top_card.power);\n\n            // * check if current player affected by the power card\n            // TODO - too closely linked to the Have another go power - needs to be handled elsewhere\n            if (current_player.getEffectState() !== PLAYER_STATES.EFFECT_NO_EFFECT) {\n\n                // * resolve power effect\n                resolvePowerEffectState(\n                    current_player,\n                    current_player.getEffectState()\n                );\n\n                return;\n            }\n        }\n    }\n\n    // * check if win condition has been reached\n    if (!hasWinConditionBeenReached()) {\n\n        debugDetail(`------------`);\n        onEndTurn();\n    } else {\n\n        // * Game has been won, end\n        outputToBoard(`${Players.getCurrentActivePlayer().getPlayerName()} is the winner!`);\n        debugDetail(`[endTurn] ${Players.getCurrentActivePlayer().getPlayerName()} has won!`);\n    }\n}","import debugDetail from \"../../Utilities/debugDetail\";\nimport { Players } from \"./../../Managers/managers\";\nimport endTurn from \"../End/endTurn\";\nimport playCard from \"./playCard\";\n\n// * Define Human Player Interaction\nexport default onHumanPlayerCardSelect = (event) => {\n\n    debugDetail(`[onHumanPlayerCardSelect]`);\n\n    // * check that the current player is the human player, or the user is selecting out of turn\n    if (!Players.getCurrentActivePlayer().getIsHuman()) {\n        debugDetail(`[onHumanPlayerCardSelect] Human player not currently active`);\n        return;\n    }\n\n    // * get selection target\n    const selection = event.target.parentNode || event.srcElement.parentNode;\n\n    // * make sure a card was clicked\n    if (selection.className == \"card\") {\n        // * get card reference\n        const value = selection.getAttribute('data-v');\n        const suit = selection.getAttribute('data-s');\n\n        const valid_play = playCard({ value, suit });\n\n        if (valid_play) {\n            endTurn();\n        }\n    }\n\n    // * otherwise do nothing\n}","import updateView from \"./View/updateView\";\nimport outputToBoard from \"./View/outputToBoard\";\nimport onHumanPlayerCardSelect from \"./Gameplay/Play/onHumanPlayerCardSelect\";\nimport handleCardPickup from \"./Gameplay/Pickup/handleCardPickup\";\n\nimport {\n    Game,\n    Deck,\n    Players,\n    View,\n} from \"./Managers/managers\";\n\n// * add window references for debugging\nwindow.Game = Game;\nwindow.Deck = Deck;\nwindow.Players = Players;\nwindow.View = View;\n\nimport outputToBoard from \"./View/outputToBoard\";\nimport updateView from \"./View/updateView\";\n\nconst startGame = () => {\n    // * ------ Initialisation ------- * //\n\n    // * Initialise Game World\n    Game.init({});\n\n    // * Initialise Players\n    Players.init({\n        num_players: 4,\n    });\n\n    // * Initialise View\n    View.init({\n        pickup_deck_el: document.getElementById(\"pickup_deck\"),\n        discard_deck_el: document.getElementById(\"discard_deck\"),\n        updates_board_el: document.getElementById(\"game_updates\"),\n    });\n\n    // * initialise the deck\n    Deck.init({});\n\n\n    // * ------ Preparation ------- * //\n\n    // * Create the players\n    Players.createPlayers([\n        {\n            el: document.getElementById(\"Player_0\"),\n            is_human: true,\n            name: \"Human Player\"\n        },\n        {\n            el: document.getElementById(\"Player_1\"),\n            is_human: false,\n            name: \"AI Player 1\"\n        },\n        {\n            el: document.getElementById(\"Player_2\"),\n            is_human: false,\n            name: \"AI Player 2\"\n        },\n        {\n            el: document.getElementById(\"Player_3\"),\n            is_human: false,\n            name: \"AI Player 3\"\n        },\n    ]);\n\n    // * prepare the deck\n    Deck.prepareDeck();\n\n    // * deal cards to each player\n    Deck.dealCards(Players.getPlayerList());\n\n\n    // * ------ Start Play ------- * //\n\n    // * Do initial draw\n    updateView();\n\n    // * Assign interactions to view\n    document.querySelector(\"#pickup_deck\").addEventListener(\"mousedown\", handleCardPickup);\n\n    const human_player = Players.getPlayerList().find(function (player) {\n        return player.getIsHuman();\n    });\n\n    human_player.getPlayerEl().querySelector(\".card_list\").addEventListener(\"mousedown\", onHumanPlayerCardSelect);\n\n    // *\n    outputToBoard(`The starting card is a ${Deck.getDiscardDeckTopCard().name}`);\n}\n\ndocument.querySelector(\"#game_instructions button\").addEventListener(\"click\", () => {\n    document.querySelector(\"#game_instructions\").remove();\n    startGame();\n});"],"names":["array","cb","param","scope","dir","Array","isArray","NodeList","prototype","isPrototypeOf","HTMLCollection","i","length","l","call","state","$bd47cf2c3a9471e9$export$7c3c3186c3d08d25","oldObject","newObj","key","Object","hasOwnProperty","$6b759888619604d5$export$b8af8fc636c3246c","mode","active_player","AI_interval_speed","AI_interval","init","getCurrentGameState","current_game_state","setCurrentGameState","game_state","$709be90538d601ca$export$9099ad97b570f7c","debugDetail","detail","console","log","$072b661429f6bfb4$export$ba9425fdd23ccf39","$072b661429f6bfb4$export$7db09e96a38164f0","$072b661429f6bfb4$export$e129b3516e9b89f1","$072b661429f6bfb4$export$45f6e32318b7e70","$072b661429f6bfb4$export$3b18bf8db35c1781","$072b661429f6bfb4$export$75ae0525279d7989","$e0a659e72339ebcc$export$17a16887dec63cf9","value","suit","name","t","power","$e666b44ca4437557$export$20ffe41b7193b8a9","PICKUP_DECK","DISCARD_DECK","starting_hand_size","shufflePickUpDeck","shuffle","removeCardByIndexFromPickupDeck","insertCardAtIndexToPickupDeck","deck","get","insert","r","card","$80e0f47ae126f8b4$export$9099ad97b570f7c","c","idx","Math","floor","random","getDiscardDeckSize","splice","removeCardByIndexFromDiscardDeck","removeFirstNCardsFromPickupDeck","num_cards","removeCardAtIndexFromDiscardDeck","insertCardAtIndexToDiscardDeck","insertToTopOfPickupDeck","unshift","insertToTopOfDiscardDeck","config","prepareDeck","getPickupDeck","getPickupDeckSize","getPickupDeckTopCard","removeCardAtIndexFromPickupDeck","getDiscardDeck","getDiscardDeckTopCard","removeFirstNCardsFromDiscardDeck","shuffleDiscardDeck","swapDecks","top_discard_card","dealCards","players","player","p","cards","addCards","$e666b44ca4437557$var$DeckManager","$2ffbe33e0da8b516$export$956e9873de14b510","$2ffbe33e0da8b516$export$40ccb1040d2dac1b","$2ffbe33e0da8b516$export$27ce1dfb0d23c5d9","$2ffbe33e0da8b516$export$2d2708adb0aa9def","$2ffbe33e0da8b516$export$1589473b83eaf132","$2ffbe33e0da8b516$export$4cdadcb89c669fa","$2ffbe33e0da8b516$export$25d3d9ee17553480","$2ffbe33e0da8b516$export$20f31bf76ab0c0e7","$2ffbe33e0da8b516$export$830a9b82a0e63fd4","$2ffbe33e0da8b516$export$c917356a60ebc691","$2ffbe33e0da8b516$export$1a317aa94554970c","$c7bdeb769f8eb495$export$6102449f17319186","num_players","player_list","current_player_idx","previous_player_idx","next_player_idx","play_direction","determineNextPlayerIdx","next_idx","determinePreviousPlayerIdx","prev_idx","createPlayers","player_configs","el","is_human","status","play_state","action","effect","addCard","push","concat","removeCard","cardIdx","findIndex","error","removeCardAtIndex","removeCards","getPlayerName","getCurrentCards","getIsHuman","getHandSize","getPlayerEl","resetStatus","getStatus","updatePlayState","includes","getPlayState","updateActionState","action_state","getActionState","updateEffectState","effect_state","getEffectState","$b2e326009819d3d3$export$271aa840ccfeca27","setNextActivePlayer","current_player","getCurrentActivePlayer","getCurrentActivePlayerIdx","getCurrentNextPlayer","getCurrentNextPlayerIdx","getCurrentPreviousPlayer","getCurrentPreviousPlayerIdx","getPlayerList","changePlayDirection","$c7bdeb769f8eb495$var$PlayerManager","$490761203a903d54$export$ee39aefc8ac7973d","pickup_deck_el","discard_deck_el","updates_board_el","card_w","card_h","createCardHTML","is_facing","createListedCardHTML","getGameUpdateBoard","$490761203a903d54$var$ViewManager","$c6d5cfd272b50308$export$9099ad97b570f7c","drawPlayerDecks","deck_el","querySelector","innerHTML","insertAdjacentHTML","$c8006a83cbdea0bf$export$9099ad97b570f7c","drawDiscardDeck","$4d14bfb8b920b32b$export$9099ad97b570f7c","updateView","$8b1b2987abd0e16d$export$9099ad97b570f7c","outputToBoard","message","update_board","scrollTop","scrollHeight","$43d2e7e4e8ff19ec$export$9099ad97b570f7c","hasWinConditionBeenReached","num_cards_remaining","$3e84c2b4171d06ca$export$9099ad97b570f7c","applyPowerEffect","current_active_player","current_next_player","$4b148b2c6c78aa1f$export$9099ad97b570f7c","checkLegalPlayableMove","current_top_card","$d058164f38109358$export$9099ad97b570f7c","handlePlayCard","$4a925ee0c3d583e3$export$9099ad97b570f7c","playCard","$f6587159d5b307ac$export$9099ad97b570f7c","onAIPlayerCardSelect","playable_cards","available_power_cards","filter","playing_card","$14403d54d4dceea8$export$9099ad97b570f7c","$f5882f68f94182a5$export$9099ad97b570f7c","pickupCardFromDeck","top_card","$f85adabb3909f708$export$9099ad97b570f7c","handleCardPickup","e","$a6def926863d4658$export$9099ad97b570f7c","chooseAIPlayerActionChoice","Players","$8c799b6bfca02efd$export$9099ad97b570f7c","handleTurnBegin","$b687bed454fd473a$export$9099ad97b570f7c","window","setTimeout","resolvePowerEffectState","currentPlayer","c1","$d77d560c0aa49997$export$9099ad97b570f7c","onEndTurn","endTurn","Deck","$fbb6e586a72a0540$export$9099ad97b570f7c","onHumanPlayerCardSelect","event","selection","target","parentNode","srcElement","className","getAttribute","Game","View","document","addEventListener","remove","getElementById","find"],"version":3,"file":"index.aaa7424f.js.map"}